"""Harness deploy service â€” deploy configs to GitHub."""

import json
import os
from http import HTTPStatus
from typing import Tuple

import yaml

from ..database import (
    get_agent,
    get_project_detail,
    get_team_detail,
    get_team_members,
)
from .github_service import GitHubService


class HarnessDeployService:
    """Service for deploying Claude Code harness settings to GitHub."""

    @classmethod
    def deploy_to_github(cls, project_id: str) -> Tuple[dict, HTTPStatus]:
        """Deploy harness settings to a project's GitHub repository.

        Generates .claude folder with all project settings and creates a PR.

        Returns:
            Tuple of (result dict with PR URL, HTTP status)
        """
        project = get_project_detail(project_id)
        if not project:
            return {"error": "Project not found"}, HTTPStatus.NOT_FOUND

        github_repo = project.get("github_repo")
        if not github_repo:
            return {
                "error": "No GitHub repository configured for this project",
                "project_id": project_id,
            }, HTTPStatus.BAD_REQUEST

        clone_path = None
        try:
            github_host = project.get("github_host", "github.com")
            repo_url = f"https://{github_host}/{github_repo}"
            clone_path = GitHubService.clone_repo(repo_url)

            # Generate harness files
            generated = cls._generate_harness_files(project, clone_path)

            if not generated["files_created"]:
                return {
                    "message": "No harness files to deploy",
                    "project_id": project_id,
                    "github_repo": github_repo,
                }, HTTPStatus.OK

            # Create branch, commit, and push
            branch_name = f"harness-update/{project_id[:8]}"
            if not GitHubService.create_branch(clone_path, branch_name):
                return {
                    "error": "Failed to create branch",
                    "project_id": project_id,
                }, HTTPStatus.INTERNAL_SERVER_ERROR

            commit_msg = f"Update harness settings for {project.get('name', project_id)}"
            if not GitHubService.commit_changes(clone_path, commit_msg):
                return {
                    "message": "No changes to deploy",
                    "project_id": project_id,
                    "github_repo": github_repo,
                }, HTTPStatus.OK

            if not GitHubService.push_branch(clone_path, branch_name):
                return {
                    "error": "Failed to push branch",
                    "project_id": project_id,
                }, HTTPStatus.INTERNAL_SERVER_ERROR

            # Create PR
            pr_title = f"Update harness settings for {project.get('name', project_id)}"
            pr_body = f"""## Harness Settings Update

This PR updates the Claude Code harness settings for the project.

### Changes
- Teams: {generated["counts"].get("teams", 0)} files
- Skills: {generated["counts"].get("skills", 0)} files

Generated by Agented Agentic Harness.
"""
            pr_url = GitHubService.create_pull_request(clone_path, branch_name, pr_title, pr_body)

            return {
                "message": "Harness settings deployed successfully",
                "project_id": project_id,
                "github_repo": github_repo,
                "pr_url": pr_url,
                "branch": branch_name,
                "generated": generated,
            }, HTTPStatus.OK

        except Exception as e:
            return {
                "error": f"Failed to deploy harness settings: {str(e)}",
                "project_id": project_id,
            }, HTTPStatus.INTERNAL_SERVER_ERROR
        finally:
            if clone_path:
                GitHubService.cleanup_clone(clone_path)

    @classmethod
    def _generate_harness_files(cls, project: dict, clone_path: str) -> dict:
        """Generate harness files in the cloned repository."""
        claude_path = os.path.join(clone_path, ".claude")
        os.makedirs(claude_path, exist_ok=True)

        files_created = []
        counts = {"teams": 0, "skills": 0, "agents": 0}

        # Generate team files
        teams = project.get("teams", [])
        if teams:
            teams_path = os.path.join(claude_path, "teams")
            os.makedirs(teams_path, exist_ok=True)

            for team in teams:
                team_id = team.get("id")
                if not team_id:
                    continue

                team_detail = get_team_detail(team_id)
                if not team_detail:
                    continue

                members = get_team_members(team_id)
                team_detail["members"] = members

                # Generate safe folder name
                team_name = team_detail.get("name", f"team-{team_id}")
                if ":" in team_name:
                    team_name = team_name.split(":", 1)[1]
                safe_name = team_name.lower().replace(" ", "-").replace(":", "-")

                team_folder = os.path.join(teams_path, safe_name)
                os.makedirs(team_folder, exist_ok=True)

                # Generate TEAM.md
                team_md = cls._generate_team_md(team_detail)
                team_md_path = os.path.join(team_folder, "TEAM.md")
                with open(team_md_path, "w") as f:
                    f.write(team_md)
                files_created.append(f".claude/teams/{safe_name}/TEAM.md")
                counts["teams"] += 1

        # Collect skills from team members' agents
        skills_path = os.path.join(claude_path, "skills")
        all_skills = set()

        for team in teams:
            team_id = team.get("id")
            if not team_id:
                continue

            # Get team members and their associated agents
            members = get_team_members(team_id)
            for member in members:
                agent_id = member.get("agent_id")
                if not agent_id:
                    continue

                agent = get_agent(agent_id)
                if not agent:
                    continue

                skills = agent.get("skills", [])
                if isinstance(skills, str):
                    try:
                        skills = json.loads(skills)
                    except json.JSONDecodeError:
                        skills = []
                all_skills.update(skills)

        # Create skill placeholders
        if all_skills:
            os.makedirs(skills_path, exist_ok=True)
            for skill in all_skills:
                skill_folder = os.path.join(skills_path, skill)
                os.makedirs(skill_folder, exist_ok=True)
                skill_md_path = os.path.join(skill_folder, "SKILL.md")
                if not os.path.exists(skill_md_path):
                    with open(skill_md_path, "w") as f:
                        f.write(f"---\nname: {skill}\n---\n\n# {skill}\n\nSkill placeholder.\n")
                    files_created.append(f".claude/skills/{skill}/SKILL.md")
                    counts["skills"] += 1

        return {
            "files_created": files_created,
            "counts": counts,
        }

    @classmethod
    def _generate_team_md(cls, team: dict) -> str:
        """Generate TEAM.md with YAML frontmatter."""
        frontmatter = {
            "name": team.get("name", ""),
        }

        if team.get("description"):
            frontmatter["description"] = team["description"]

        if team.get("leader_name"):
            frontmatter["lead"] = team["leader_name"]

        members = team.get("members", [])
        if members:
            frontmatter["members"] = []
            for member in members:
                member_entry = {
                    "name": member.get("name", ""),
                    "role": member.get("role", "member"),
                }
                if member.get("description"):
                    member_entry["description"] = member["description"]
                frontmatter["members"].append(member_entry)

        yaml_content = yaml.dump(
            frontmatter,
            default_flow_style=False,
            allow_unicode=True,
            sort_keys=False,
        )

        md_content = f"---\n{yaml_content}---\n\n"

        if team.get("description"):
            md_content += f"# {team['name']}\n\n{team['description']}\n"

        return md_content
