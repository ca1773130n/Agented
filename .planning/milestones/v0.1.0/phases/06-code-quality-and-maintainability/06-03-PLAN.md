---
phase: 06-code-quality-and-maintainability
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - backend/app/services/prompt_renderer.py
  - backend/app/services/command_builder.py
  - backend/app/services/execution_service.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "`PromptRenderer` class exists in `backend/app/services/prompt_renderer.py` with a `render()` static method and a `warn_unresolved()` static method"
    - "`CommandBuilder` class exists in `backend/app/services/command_builder.py` with a `build()` static method"
    - "`ExecutionService.build_command()` delegates to `CommandBuilder.build()` -- the method signature is unchanged"
    - "`ExecutionService.run_trigger()` uses `PromptRenderer.render()` and `PromptRenderer.warn_unresolved()` for prompt construction"
    - "`cd backend && uv run pytest` passes at 100% with NO changes to any test file"
    - "All existing test mock paths (`app.services.execution_service.ExecutionService.build_command`, `app.services.execution_service.ExecutionService.run_trigger`) still resolve correctly"
  artifacts:
    - path: "backend/app/services/prompt_renderer.py"
      provides: "Stateless prompt template rendering class"
      min_lines: 50
      exports: ["PromptRenderer"]
    - path: "backend/app/services/command_builder.py"
      provides: "Stateless CLI command construction class"
      min_lines: 40
      exports: ["CommandBuilder"]
  key_links:
    - from: "backend/app/services/execution_service.py"
      to: "backend/app/services/prompt_renderer.py"
      via: "import and delegation in run_trigger"
      pattern: "from .prompt_renderer import PromptRenderer"
    - from: "backend/app/services/execution_service.py"
      to: "backend/app/services/command_builder.py"
      via: "import and delegation in build_command"
      pattern: "from .command_builder import CommandBuilder"
    - from: "backend/tests/test_backend_detection.py"
      to: "backend/app/services/execution_service.py"
      via: "direct call to ExecutionService.build_command()"
      pattern: "ExecutionService.build_command"
---

<objective>
Split `ExecutionService` into a coordinator (facade) plus two stateless helper classes (`PromptRenderer` and `CommandBuilder`), preserving the existing public API so all test call sites continue working without modification.

Purpose: `ExecutionService` is 1,387 lines and violates SRP (Fowler "Refactoring" 2018, Martin "Clean Architecture" 2017 -- Extract Class pattern). Two pure-function extraction targets exist: `build_command()` (a `@staticmethod`, lines 434-485) and prompt rendering logic (lines 628-677 of `run_trigger`, stateless string replacements). Extracting them improves testability and readability while reducing `run_trigger` by ~80 lines.

Output: `prompt_renderer.py` (~80 lines), `command_builder.py` (~70 lines), updated `execution_service.py` that delegates to both.

Research basis: Fowler "Refactoring" (2018) Extract Class pattern; Martin "Clean Architecture" (2017) SRP.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/06-code-quality-and-maintainability/06-RESEARCH.md
</execution_context>

<context>
@.planning/codebase/ARCHITECTURE.md
@backend/app/services/execution_service.py
@backend/tests/test_backend_detection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PromptRenderer and CommandBuilder helper classes</name>
  <files>backend/app/services/prompt_renderer.py, backend/app/services/command_builder.py</files>
  <action>
    **Create `backend/app/services/command_builder.py`:**

    1. Define `CommandBuilder` class with a single `@staticmethod` method `build()` that contains the EXACT logic currently in `ExecutionService.build_command()` (lines 434-485 of `execution_service.py`).
    2. Method signature: `build(backend: str, prompt: str, allowed_paths: list = None, model: str = None, codex_settings: dict = None, allowed_tools: str = None) -> list`
    3. Copy the implementation verbatim -- the 4 backend branches (opencode, gemini, codex, claude default) with their model/path/tool handling.
    4. Add module docstring and class docstring explaining this is a stateless CLI command construction helper extracted from ExecutionService.

    **Create `backend/app/services/prompt_renderer.py`:**

    1. Define `PromptRenderer` class with two `@staticmethod` methods:

    2. `render(trigger: dict, trigger_id: str, message_text: str, paths_str: str, event: dict = None) -> str`:
       - Contains the prompt rendering logic currently inline in `run_trigger()` (lines 628-670 of `execution_service.py`).
       - Performs: template extraction from `trigger["prompt_template"]`, `{trigger_id}` / `{bot_id}` / `{paths}` / `{message}` replacement, GitHub PR placeholder replacement when `event` is a `github_pr` type, and skill_command prepending.
       - Does NOT include the security audit threat report logic (lines 672-677) -- that stays in `run_trigger` because it has side effects (file I/O via `cls.save_threat_report`).

    3. `warn_unresolved(prompt: str, trigger_name: str, logger) -> None`:
       - Contains the unresolved placeholder warning logic (lines 646-665 of `execution_service.py`).
       - Imports `re` at module level.
       - Defines `_KNOWN_PLACEHOLDERS` as a class-level set constant.

    4. Add module docstring and class docstring explaining this is a stateless prompt template rendering helper extracted from ExecutionService.

    **Critical: Preserve exact behavior.** The extracted code must produce identical outputs for identical inputs. No logic changes, no added features, no removed edge cases.
  </action>
  <verify>
    cd backend && uv run python -c "from app.services.prompt_renderer import PromptRenderer; print('OK')" && uv run python -c "from app.services.command_builder import CommandBuilder; print('OK')" (Level 1: Sanity)
  </verify>
  <done>
    Both helper classes exist, import cleanly, and contain the extracted logic with identical behavior to the original.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ExecutionService to delegate to helpers (facade pattern)</name>
  <files>backend/app/services/execution_service.py</files>
  <action>
    1. **Add imports** at the top of `execution_service.py`:
       ```python
       from .prompt_renderer import PromptRenderer
       from .command_builder import CommandBuilder
       ```

    2. **Replace `build_command` body** with delegation:
       Keep the `@staticmethod` decorator and exact method signature unchanged. Replace the body with:
       ```python
       return CommandBuilder.build(
           backend, prompt, allowed_paths, model, codex_settings, allowed_tools
       )
       ```
       This preserves the public API at `ExecutionService.build_command()` so all test call sites like `ExecutionService.build_command("claude", "test prompt")` in `test_backend_detection.py` continue to work.

    3. **Replace inline prompt rendering in `run_trigger`** (lines 627-670) with:
       ```python
       prompt = PromptRenderer.render(trigger, trigger_id, message_text, paths_str, event)
       PromptRenderer.warn_unresolved(prompt, trigger.get("name", trigger_id), logger)
       ```
       Keep the security audit threat report logic (lines 672-677) in place -- it has side effects.
       Keep the `paths_str` computation (line 625) in place -- it depends on `effective_paths` which is computed in the preceding clone logic.

    4. **Remove the `_KNOWN_PLACEHOLDERS` set** from `run_trigger` (lines 646-657) since it now lives in `PromptRenderer`.

    5. **Remove the `import re`** from the top of execution_service.py ONLY if `re` is no longer used elsewhere in the file. Check first -- `re` is used for rate limit detection patterns. If `re` is used elsewhere, keep the import.

    **Pitfall avoidance (from RESEARCH.md Pitfall 4):**
    - `build_command` stays as a method on `ExecutionService` that delegates. Tests that mock `app.services.execution_service.ExecutionService.build_command` continue to work because the method still exists at that path.
    - `run_trigger` stays as a method on `ExecutionService`. Tests that mock `app.services.execution_service.ExecutionService.run_trigger` continue to work.
    - No test file modifications are allowed. If any test fails, the delegation is wrong -- fix the helper, not the test.
  </action>
  <verify>
    cd backend && uv run pytest --tb=short -v (Level 2: Proxy)

    Specifically verify:
    - `uv run pytest tests/test_backend_detection.py -v` -- all 7 TestBuildCommand tests pass
    - `uv run pytest tests/test_budget_integration.py -v` -- all run_trigger integration tests pass
    - `uv run pytest tests/test_team_execution.py -v` -- team execution tests pass
    - `uv run pytest tests/test_agent_scheduler.py -v` -- scheduler tests pass
  </verify>
  <done>
    `ExecutionService.build_command()` delegates to `CommandBuilder.build()`. `run_trigger` uses `PromptRenderer.render()` and `PromptRenderer.warn_unresolved()`. Full test suite passes at 100% with zero test modifications. `execution_service.py` is reduced by ~80 lines.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run python -c "from app.services.prompt_renderer import PromptRenderer"` exits 0
- `cd backend && uv run python -c "from app.services.command_builder import CommandBuilder"` exits 0
- `grep -q "CommandBuilder.build" backend/app/services/execution_service.py` returns 0
- `grep -q "PromptRenderer.render" backend/app/services/execution_service.py` returns 0

Level 2 (Proxy):
- `cd backend && uv run pytest` passes at 100%
- `cd backend && uv run pytest tests/test_backend_detection.py::TestBuildCommand -v` -- all 7 tests pass
- `cd backend && uv run pytest tests/test_budget_integration.py -v` -- all integration tests pass
- No test files modified (verify with `git diff --name-only -- backend/tests/`)
</verification>

<success_criteria>
- `PromptRenderer` class in `prompt_renderer.py` with `render()` and `warn_unresolved()` static methods
- `CommandBuilder` class in `command_builder.py` with `build()` static method
- `ExecutionService.build_command()` delegates to `CommandBuilder.build()` with unchanged signature
- `ExecutionService.run_trigger()` uses `PromptRenderer` for prompt construction
- Full test suite passes with zero test file modifications
- `execution_service.py` line count reduced by at least 60 lines
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/06-code-quality-and-maintainability/06-03-SUMMARY.md`
</output>
