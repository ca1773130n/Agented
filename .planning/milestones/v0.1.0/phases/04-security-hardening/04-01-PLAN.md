---
phase: 04-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/uv.lock
  - backend/app/__init__.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "Every HTTP response from the backend includes Content-Security-Policy, Strict-Transport-Security, X-Frame-Options: DENY, and X-Content-Type-Options: nosniff headers"
    - "flask-talisman is initialized in create_app() after CORS and before blueprint registration"
    - "flask-limiter is initialized in create_app() with storage_uri='memory://' and stored on app.extensions['limiter']"
    - "A custom 429 error handler returns JSON matching the project's error response format"
    - "force_https defaults to False (controllable via FORCE_HTTPS env var) to prevent redirect loops in development"
    - "CSP allows 'unsafe-inline' for script-src and style-src to avoid breaking Swagger UI at /docs"
  artifacts:
    - path: "backend/pyproject.toml"
      provides: "flask-talisman and flask-limiter dependencies"
      contains: "flask-talisman"
    - path: "backend/app/__init__.py"
      provides: "Security extension initialization in app factory"
      contains: "Talisman"
  key_links:
    - from: "backend/app/__init__.py"
      to: "flask_talisman"
      via: "import and initialization"
      pattern: "from flask_talisman import Talisman"
    - from: "backend/app/__init__.py"
      to: "flask_limiter"
      via: "import and initialization"
      pattern: "from flask_limiter import Limiter"
---

<objective>
Install flask-talisman and flask-limiter, initialize both extensions in the app factory, and register a custom JSON 429 error handler.

Purpose: Establish the security middleware foundation (SEC-01 headers on all responses, SEC-02 limiter object available for blueprint-level limits in Plan 02) so that downstream plans can apply per-route rate limits and verify header presence.

Output: Updated `create_app()` with Talisman and Limiter extensions initialized; updated `pyproject.toml` with new dependencies; custom 429 JSON error handler.

Research basis: flask-talisman (GoogleCloudPlatform) for OWASP-aligned security headers; flask-limiter 3.x with in-memory storage for single-worker Gunicorn deployment (safe per flask-limiter Discussion #373 and gunicorn.conf.py workers=1 constraint).
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/04-security-hardening/04-RESEARCH.md
</execution_context>

<context>
@.planning/milestones/v0.1.0/ROADMAP.md
@backend/app/__init__.py
@backend/pyproject.toml
@backend/gunicorn.conf.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flask-talisman and flask-limiter dependencies</name>
  <files>backend/pyproject.toml, backend/uv.lock</files>
  <action>
    Add `flask-talisman>=1.1.0` and `flask-limiter>=3.0.0` to the `dependencies` list in `backend/pyproject.toml`.

    Then run `cd backend && uv sync` to install both packages and update `uv.lock`.

    Verify both are importable:
    ```
    cd backend && uv run python -c "from flask_talisman import Talisman; print('talisman ok')"
    cd backend && uv run python -c "from flask_limiter import Limiter; print('limiter ok')"
    ```

    Do NOT add any other dependencies. `limits` (the rate limit parsing library) is a transitive dependency of flask-limiter and should not be listed explicitly.
  </action>
  <verify>
    `cd backend && uv sync` exits 0 (Level 1: Sanity)
    Both `from flask_talisman import Talisman` and `from flask_limiter import Limiter` succeed (Level 1: Sanity)
  </verify>
  <done>flask-talisman and flask-limiter listed in pyproject.toml dependencies; uv.lock updated; both packages importable</done>
</task>

<task type="auto">
  <name>Task 2: Initialize Talisman, Limiter, and 429 handler in create_app()</name>
  <files>backend/app/__init__.py</files>
  <action>
    Modify `create_app()` in `backend/app/__init__.py` to initialize flask-talisman and flask-limiter.

    **Add imports at the top of the file** (after existing imports):
    ```python
    from flask_talisman import Talisman
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    ```

    **Initialize Talisman AFTER the CORS block and BEFORE blueprint registration.** Based on the 04-RESEARCH.md recommendation and OWASP Secure Headers Project guidance, use these settings:

    ```python
    # Security headers (SEC-01) — OWASP-aligned via flask-talisman
    # Initialize AFTER CORS so CORS headers are set first (no conflict — different headers)
    Talisman(
        app,
        force_https=os.environ.get("FORCE_HTTPS", "false").lower() == "true",
        frame_options="DENY",
        strict_transport_security=True,
        strict_transport_security_max_age=31536000,  # 1 year
        strict_transport_security_include_subdomains=True,
        content_security_policy={
            "default-src": "'self'",
            "script-src": ["'self'", "'unsafe-inline'"],  # Swagger UI needs inline scripts
            "style-src": ["'self'", "'unsafe-inline'"],   # Swagger UI needs inline styles
            "img-src": ["'self'", "data:"],
            "connect-src": ["'self'"],
        },
        content_security_policy_report_only=False,
        referrer_policy="strict-origin-when-cross-origin",
    )
    ```

    **Key pitfall to avoid (from 04-RESEARCH.md Pitfall 2):** `force_https` MUST default to `False` unless `FORCE_HTTPS=true` is set. The development setup uses plain HTTP (port 20000). Setting `force_https=True` would cause infinite redirect loops.

    **Key pitfall to avoid (from 04-RESEARCH.md Pitfall 1):** CSP MUST include `'unsafe-inline'` for `script-src` and `style-src` to prevent breaking Swagger UI at `/docs`. Without this, the docs page renders blank.

    **Initialize Limiter immediately after Talisman** (still before blueprint registration):

    ```python
    # Rate limiting (SEC-02) — in-memory storage safe for workers=1 (see gunicorn.conf.py)
    limiter = Limiter(
        get_remote_address,
        app=app,
        default_limits=[],  # No global default — limits applied per-blueprint in register_blueprints()
        storage_uri="memory://",
        strategy="fixed-window",
    )
    # Store on app.extensions for blueprint-level access in register_blueprints()
    app.extensions["limiter"] = limiter
    ```

    **Add custom JSON 429 error handler** alongside the existing error handlers (after the `@app.errorhandler(500)` block):

    ```python
    @app.errorhandler(429)
    def ratelimit_handler(e):
        return {"error": f"Rate limit exceeded: {e.description}"}, 429
    ```

    This avoids 04-RESEARCH.md Pitfall 3 (flask-limiter's default 429 is HTML, but the frontend expects JSON).

    **IMPORTANT placement order in create_app():**
    1. App creation and config
    2. CORS initialization (existing)
    3. Talisman initialization (NEW)
    4. Limiter initialization (NEW)
    5. Service initialization (existing, inside `if not testing:`)
    6. Blueprint registration (existing)
    7. Error handlers (existing + NEW 429 handler)

    Note: Place Talisman and Limiter initialization OUTSIDE the `if not testing:` block so that security headers and rate limiting are active during tests too. This matches how CORS is currently initialized (outside the testing guard).
  </action>
  <verify>
    Start the backend (`cd backend && uv run python run.py --debug`) and run:
    ```
    curl -I http://localhost:20000/health/liveness
    ```
    Verify response includes all four security headers (Level 2: Proxy):
    - Content-Security-Policy
    - Strict-Transport-Security
    - X-Frame-Options: DENY
    - X-Content-Type-Options: nosniff

    Verify Swagger UI at http://localhost:20000/docs still loads and "Try It Out" works (Level 2: Proxy).

    Run `cd backend && uv run pytest` — all tests pass (Level 1: Sanity).
    Run `just build` — frontend build succeeds (Level 1: Sanity).
  </verify>
  <done>
    Talisman initialized with OWASP-aligned headers (CSP, HSTS, X-Frame-Options: DENY, X-Content-Type-Options: nosniff) on all responses.
    Limiter initialized with in-memory storage and stored on app.extensions["limiter"] for blueprint-level access.
    Custom JSON 429 error handler registered.
    force_https defaults to False (env-configurable).
    CSP permits inline scripts/styles for Swagger UI compatibility.
    All existing tests pass. Frontend build succeeds.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- flask-talisman and flask-limiter importable after uv sync
- `cd backend && uv run pytest` passes with zero failures
- `just build` succeeds (vue-tsc + vite)

Level 2 (Proxy):
- `curl -I http://localhost:20000/health/liveness` includes Content-Security-Policy, Strict-Transport-Security, X-Frame-Options: DENY, X-Content-Type-Options: nosniff
- Swagger UI at /docs loads and interactive features work
- No HTTPS redirect on http://localhost:20000 (force_https=False)

Level 3 (Deferred):
- Verify SSE streaming endpoints still deliver events with security headers present
- Full frontend end-to-end test with security headers active
</verification>

<success_criteria>
1. `curl -I http://localhost:20000/health/liveness` response includes all four required security headers
2. `app.extensions["limiter"]` exists and is a Limiter instance (foundation for Plan 02 blueprint limits)
3. All backend tests pass; frontend build succeeds
4. Swagger UI at /docs is fully functional (not broken by CSP)
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/04-security-hardening/04-01-SUMMARY.md`
</output>
