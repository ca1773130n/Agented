---
phase: 04-security-hardening
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/routes/__init__.py
  - backend/app/routes/health.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "Sending 20 POST requests to / within 10 seconds succeeds; the 21st returns HTTP 429 with a JSON error body"
    - "GitHub webhook endpoint (/api/webhooks/github/) has a rate limit of 30 requests per minute"
    - "Admin routes have a rate limit of 120 requests per minute per IP"
    - "Health and docs blueprints are exempt from rate limiting"
    - "GET /health/readiness without authentication returns only {status, timestamp} — no execution IDs, process PIDs, CLIProxy ports, or startup warnings"
    - "GET /health/readiness with a valid X-API-Key header (matching AGENTED_API_KEY env var) returns full component health details including database, process_manager, cli_proxy, and startup components"
  artifacts:
    - path: "backend/app/routes/__init__.py"
      provides: "Blueprint-level rate limit application and exemptions"
      contains: "limiter"
    - path: "backend/app/routes/health.py"
      provides: "Conditional health endpoint redaction for unauthenticated callers"
      contains: "X-API-Key"
  key_links:
    - from: "backend/app/routes/__init__.py"
      to: "backend/app/__init__.py"
      via: "app.extensions['limiter'] access"
      pattern: "app.extensions.*limiter"
    - from: "backend/app/routes/health.py"
      to: "os.environ"
      via: "API key comparison against AGENTED_API_KEY env var"
      pattern: "AGENTED_API_KEY|X-API-Key"
---

<objective>
Apply per-blueprint rate limits to webhook and admin routes, exempt health and docs from rate limiting, and redact sensitive fields from the health readiness endpoint for unauthenticated callers.

Purpose: Complete SEC-02 (rate limiting enforcement) and SEC-03 (health endpoint redaction) by wiring the Limiter instance from Plan 01 to specific blueprints and adding conditional response logic to the readiness probe.

Output: Updated `register_blueprints()` with rate limit decorators and exemptions; updated `readiness()` with auth-conditional response redaction.

Research basis: flask-limiter blueprint-level limits (Context7 /alisaifee/flask-limiter); OWASP API Security Top 10 (2023) API3:2023 for minimum-data responses to unauthenticated callers.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/04-security-hardening/04-RESEARCH.md
@.planning/milestones/v0.1.0/phases/04-security-hardening/04-01-PLAN.md
</execution_context>

<context>
@.planning/milestones/v0.1.0/ROADMAP.md
@backend/app/routes/__init__.py
@backend/app/routes/health.py
@backend/app/routes/webhook.py
@backend/app/routes/github_webhook.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply blueprint-level rate limits and exemptions in register_blueprints()</name>
  <files>backend/app/routes/__init__.py</files>
  <action>
    Modify `register_blueprints()` in `backend/app/routes/__init__.py` to apply rate limits using the Limiter instance stored on `app.extensions["limiter"]` by Plan 01.

    **CRITICAL ordering requirement:** Flask-limiter's official documentation (Context7 /alisaifee/flask-limiter recipes) shows `limiter.limit()(bp)` and `limiter.exempt(bp)` called BEFORE `app.register_blueprint(bp)`. Rate limit decoration applied post-registration may silently fail to cover already-registered view functions. Therefore, rate limits MUST be applied to each blueprint BEFORE its `app.register_api()` call.

    **Replace the entire function body** (after the `def register_blueprints(app):` signature) with the complete implementation below. The rate-limit block is inserted between the last import and the first `app.register_api()` call:

    ```python
    def register_blueprints(app):
        """Register all route blueprints with the Flask app."""
        from .agent_conversations import agent_conversations_bp
        from .agents import agents_bp
        from .audit import audit_bp
        from .backends import backends_bp
        from .budgets import budgets_bp
        from .command_conversations import command_conversations_bp
        from .commands import commands_bp
        from .executions import executions_bp
        from .github_webhook import github_webhook_bp
        from .grd import grd_bp
        from .health import health_bp
        from .hook_conversations import hook_conversations_bp
        from .hooks import hooks_bp
        from .marketplace import marketplace_bp
        from .mcp_servers import mcp_servers_bp, project_mcp_bp
        from .monitoring import monitoring_bp
        from .orchestration import orchestration_bp
        from .plugin_conversations import plugin_conversations_bp
        from .plugin_exports import plugin_exports_bp
        from .plugins import plugins_bp
        from .pr_reviews import pr_reviews_bp
        from .product_owner import product_owner_bp
        from .products import products_bp
        from .projects import projects_bp
        from .rotation import rotation_bp
        from .rule_conversations import rule_conversations_bp
        from .rules import rules_bp
        from .scheduler import scheduler_bp
        from .settings import settings_bp
        from .setup import setup_bp
        from .sketches import sketches_bp
        from .skill_conversations import skill_conversations_bp
        from .skills import skills_bp
        from .spa import spa_bp
        from .super_agent_exports import super_agent_exports_bp
        from .super_agents import super_agents_bp
        from .teams import teams_bp
        from .triggers import triggers_bp
        from .utility import utility_bp
        from .webhook import webhook_bp
        from .workflows import workflows_bp

        # --- Rate limiting (SEC-02) ---
        # Apply rate limits BEFORE blueprint registration (flask-limiter official pattern).
        # Retrieve limiter from app extensions (initialized in create_app by Plan 01)
        limiter = app.extensions.get("limiter")
        if limiter:
            # Webhook ingestion: 20 requests per 10 seconds per IP
            # Success criteria: 21st request within 10s returns HTTP 429
            limiter.limit("20/10seconds")(webhook_bp)

            # GitHub webhook: 30 requests per minute per IP
            limiter.limit("30/minute")(github_webhook_bp)

            # Admin routes: 120 requests per minute per IP
            # Generous limit to accommodate SPA page loads, AJAX calls, and SSE reconnects
            # (See 04-RESEARCH.md Pitfall 4: tight limits break SSE EventSource reconnect)
            admin_blueprints = [
                triggers_bp, audit_bp, utility_bp, executions_bp, pr_reviews_bp,
                agents_bp, agent_conversations_bp, skills_bp, teams_bp,
                products_bp, projects_bp, plugins_bp, marketplace_bp,
                settings_bp, hooks_bp, commands_bp, rules_bp,
                skill_conversations_bp, plugin_conversations_bp,
                hook_conversations_bp, command_conversations_bp,
                rule_conversations_bp, backends_bp, orchestration_bp,
                budgets_bp, plugin_exports_bp, monitoring_bp, scheduler_bp,
                setup_bp, super_agents_bp, super_agent_exports_bp,
                workflows_bp, sketches_bp, grd_bp, rotation_bp,
                mcp_servers_bp, project_mcp_bp, product_owner_bp,
            ]
            for bp in admin_blueprints:
                limiter.limit("120/minute")(bp)

            # Exempt health from rate limiting
            # (04-RESEARCH.md: health probes must always respond)
            limiter.exempt(health_bp)

        # Register blueprints (AFTER rate limit decoration)
        app.register_api(health_bp)
        app.register_api(webhook_bp)
        app.register_api(github_webhook_bp)
        app.register_api(triggers_bp)
        app.register_api(audit_bp)
        app.register_api(utility_bp)
        app.register_api(executions_bp)
        app.register_api(pr_reviews_bp)
        app.register_api(agents_bp)
        app.register_api(agent_conversations_bp)
        app.register_api(skills_bp)
        app.register_api(teams_bp)
        app.register_api(products_bp)
        app.register_api(projects_bp)
        app.register_api(plugins_bp)
        app.register_api(marketplace_bp)
        app.register_api(settings_bp)
        app.register_api(hooks_bp)
        app.register_api(commands_bp)
        app.register_api(rules_bp)
        app.register_api(skill_conversations_bp)
        app.register_api(plugin_conversations_bp)
        app.register_api(hook_conversations_bp)
        app.register_api(command_conversations_bp)
        app.register_api(rule_conversations_bp)
        app.register_api(backends_bp)
        app.register_api(orchestration_bp)
        app.register_api(budgets_bp)
        app.register_api(plugin_exports_bp)
        app.register_api(monitoring_bp)
        app.register_api(scheduler_bp)
        app.register_api(setup_bp)
        app.register_api(super_agents_bp)
        app.register_api(super_agent_exports_bp)
        app.register_api(workflows_bp)
        app.register_api(sketches_bp)
        app.register_api(grd_bp)
        app.register_api(rotation_bp)
        app.register_api(mcp_servers_bp)
        app.register_api(project_mcp_bp)
        app.register_api(product_owner_bp)

        # SPA catch-all: MUST be registered LAST so API routes take priority
        app.register_blueprint(spa_bp)
    ```

    The final structure of `register_blueprints()` should be:
    1. All blueprint imports (existing, unchanged)
    2. Rate limit application block (NEW -- `limiter.limit()` and `limiter.exempt()` calls)
    3. All `app.register_api(...)` calls (existing, unchanged)
    4. SPA catch-all registration (existing, unchanged)

    **IMPORTANT:** The `if limiter:` guard ensures tests that do not initialize the limiter (e.g., unit tests using a bare Flask app) do not crash.

    **Key pitfall to avoid (from 04-RESEARCH.md Pitfall 4):** Admin rate limit is set to 120/minute (2/second) which accommodates normal SPA usage including SSE reconnects. Do NOT set tighter limits (e.g., 10/minute) as this would break the frontend after brief network interruptions.

    **Key pitfall to avoid (from 04-RESEARCH.md):** Do NOT rate-limit the docs endpoint. Swagger UI makes multiple XHR requests to load the OpenAPI spec, and a strict limit would break it. The docs are served by flask-openapi3's internal blueprint which is separate from the explicitly registered blueprints. Since `default_limits=[]` (no global default) and we only apply limits to explicit blueprints, docs should be inherently exempt. This assumption is verified in the `<verify>` step by sending 25 rapid GET requests to `/docs` and confirming none return 429.
  </action>
  <verify>
    Run the backend and execute a burst test (Level 2: Proxy):
    ```bash
    # Send 21 rapid POST requests to the webhook endpoint
    for i in $(seq 1 21); do
      STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -d '{}' http://localhost:20000/)
      echo "Request $i: HTTP $STATUS"
    done
    ```
    Requests 1-20 should return 200 (or 400 for empty payload — either is fine, NOT 429).
    Request 21 should return 429.

    Verify the 429 response is JSON (Level 2: Proxy):
    ```bash
    # After exhausting the limit:
    curl -s -X POST -H "Content-Type: application/json" -d '{}' http://localhost:20000/ | python -m json.tool
    ```
    Should output: `{"error": "Rate limit exceeded: ..."}` (not HTML).

    Verify GitHub webhook rate limit (Level 2: Proxy):
    ```bash
    # GitHub webhook is rate-limited at 30/minute — send 31 rapid requests
    # (unauthenticated is fine per Phase 3 bypass allowlist for /api/webhooks/github/)
    for i in $(seq 1 31); do
      STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -d '{"action":"test"}' http://localhost:20000/api/webhooks/github/)
      echo "Request $i: HTTP $STATUS"
    done
    ```
    Requests 1-30 should NOT return 429. Request 31 should return 429.

    Verify admin route rate limit (Level 2: Proxy):
    ```bash
    # Admin routes are rate-limited at 120/minute — send 121 rapid requests
    # (requires valid X-API-Key for Phase 3 auth; start backend with AGENTED_API_KEY=test-key-12345)
    for i in $(seq 1 121); do
      STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: test-key-12345" http://localhost:20000/admin/triggers)
      echo "Request $i: HTTP $STATUS"
    done
    ```
    Requests 1-120 should NOT return 429. Request 121 should return 429.
    Note: If not running with AGENTED_API_KEY set, skip this check (auth middleware will reject all requests with 401 before rate limit applies).

    Verify health endpoint is NOT rate-limited (Level 1: Sanity):
    ```bash
    for i in $(seq 1 25); do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:20000/health/liveness; done
    ```
    All 25 should return 200 (never 429).

    Verify docs endpoint is NOT rate-limited (Level 2: Proxy):
    ```bash
    for i in $(seq 1 25); do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:20000/docs; done
    ```
    All 25 should return 200 (never 429). This confirms the assumption that flask-openapi3's internal docs blueprint is exempt because `default_limits=[]` and only explicitly listed blueprints receive limits.

    Run `cd backend && uv run pytest` — all tests pass (Level 1: Sanity).
  </verify>
  <done>
    Webhook endpoint rate-limited at 20/10seconds per IP.
    GitHub webhook rate-limited at 30/minute per IP.
    All admin blueprints rate-limited at 120/minute per IP.
    Health blueprint exempt from rate limiting.
    429 response is JSON format.
    All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Redact sensitive fields from health readiness for unauthenticated callers</name>
  <files>backend/app/routes/health.py</files>
  <action>
    Modify the `readiness()` function in `backend/app/routes/health.py` to return a minimal response when the caller is not authenticated.

    **Add imports:**
    ```python
    import hmac
    import os
    from datetime import datetime, timezone
    from flask import request
    ```

    **Add a helper function above `readiness()` to check authentication independently** (does NOT rely on Phase 3 auth middleware or `g.authenticated`):

    ```python
    def _is_authenticated_request() -> bool:
        """Check if request carries a valid API key.

        Self-contained auth check for the health endpoint (SEC-03).
        Compares X-API-Key header against AGENTED_API_KEY env var — the same
        env var used by Phase 3's auth middleware in create_app().

        Returns False if AGENTED_API_KEY is not set (safe default: redact).
        """
        api_key = request.headers.get("X-API-Key")
        if not api_key:
            return False
        secret = os.environ.get("AGENTED_API_KEY", "")
        if not secret:
            return False
        return hmac.compare_digest(api_key, secret)
    ```

    **At the start of `readiness()`, check authentication status and return minimal response if unauthenticated:**

    ```python
    @health_bp.get("/readiness")
    def readiness():
        """Readiness probe with system health details.

        Unauthenticated callers receive a minimal response (SEC-03).
        Authenticated callers (valid X-API-Key header) receive full component health details.
        """
        # SEC-03: Unauthenticated callers get minimal response
        if not _is_authenticated_request():
            return {
                "status": "ok",
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }, 200

        # Full response for authenticated callers (existing logic below)
        ...
    ```

    **Key design decision:** This uses `X-API-Key` header compared against `os.environ.get("AGENTED_API_KEY")` — the same env var that Phase 3's `_require_api_key()` middleware uses in `create_app()` (line 123 of `backend/app/__init__.py`). This is NOT `app.config["SECRET_KEY"]` which is the Flask session signing key (a different value). Using `AGENTED_API_KEY` ensures that when AGENTED_API_KEY is set, callers who provide the correct key in `X-API-Key` header get the full readiness response, exactly matching Phase 3's auth semantics. The `hmac.compare_digest()` comparison prevents timing attacks, consistent with the Phase 3 middleware pattern.

    **Keep the entire existing readiness logic** (DB check, process manager check, CLIProxy check, startup warnings) inside the authenticated branch. The full existing code from line 20 onward (`from ..database import get_connection` through `return health, status_code`) stays but is only reached when `_is_authenticated_request()` returns True.

    **Explicitly: the unauthenticated response MUST NOT contain:**
    - `active_execution_ids` (execution IDs are sensitive — reveal ongoing work)
    - `active_executions` (process count)
    - CLIProxy `port` number
    - Startup `warnings` (may contain internal paths, service names, error messages)
    - `components` object (any of it)

    The unauthenticated response MUST contain ONLY:
    - `"status": "ok"` (fixed string — does not reveal actual component status)
    - `"timestamp"`: current UTC time in ISO 8601 format

    **Leave the liveness endpoint unchanged.** `/health/liveness` returns `("", 200)` with no body — it's already minimal and does not expose any sensitive data.
  </action>
  <verify>
    Test unauthenticated response (Level 1: Sanity):
    ```bash
    curl -s http://localhost:20000/health/readiness | python -m json.tool
    ```
    Should return ONLY `{"status": "ok", "timestamp": "2026-..."}`.
    Must NOT contain `active_execution_ids`, `components`, `warnings`, `port`, or `active_executions`.

    Test authenticated response (Level 2: Proxy):
    ```bash
    # Start the backend with AGENTED_API_KEY set:
    #   AGENTED_API_KEY=test-key-12345 just dev-backend
    # Then use the same key as the X-API-Key header:
    curl -s -H "X-API-Key: test-key-12345" http://localhost:20000/health/readiness | python -m json.tool
    ```
    Should return full component health details (database, process_manager, cli_proxy, startup).
    Must contain `components` key with at least `database` and `process_manager` sub-objects.

    If AGENTED_API_KEY is not set, the auth check returns False for all callers (safe default: always redact). To test the authenticated path, AGENTED_API_KEY must be set before starting the backend.

    Verify liveness still works (Level 1: Sanity):
    ```bash
    curl -s -o /dev/null -w "%{http_code}" http://localhost:20000/health/liveness
    ```
    Should return 200.

    Run `cd backend && uv run pytest` — all tests pass (Level 1: Sanity).
    Run `just build` — frontend build succeeds (Level 1: Sanity).
  </verify>
  <done>
    /health/readiness returns minimal {status, timestamp} for unauthenticated callers (no X-API-Key header).
    /health/readiness returns full component health for authenticated callers (valid X-API-Key matching AGENTED_API_KEY env var).
    Auth check is self-contained in health.py — uses os.environ.get("AGENTED_API_KEY") consistent with Phase 3 middleware.
    Uses hmac.compare_digest() for timing-safe comparison.
    No execution IDs, process PIDs, CLIProxy ports, or startup warnings exposed to unauthenticated callers.
    /health/liveness unchanged and functional.
    All backend tests pass. Frontend build succeeds.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run pytest` passes with zero failures
- `just build` succeeds (vue-tsc + vite)
- `/health/liveness` returns 200
- `/health/readiness` without auth returns only `status` and `timestamp` keys

Level 2 (Proxy):
- 20 rapid `POST /` requests succeed; 21st returns HTTP 429 with JSON body
- 30 rapid `POST /api/webhooks/github/` requests succeed; 31st returns HTTP 429
- 120 rapid `GET /admin/triggers` requests (with X-API-Key) succeed; 121st returns HTTP 429
- 429 response body is `{"error": "Rate limit exceeded: ..."}` (not HTML)
- `/health/readiness` without auth response contains no `active_execution_ids`, `components`, `warnings`, or `port`
- `/health/readiness` with valid `X-API-Key` header (matching AGENTED_API_KEY env var) returns full component health details (database, process_manager, cli_proxy, startup)
- Health endpoint is never rate-limited (25 rapid requests all return 200)
- Docs endpoint is never rate-limited (25 rapid GET /docs requests all return 200)
- Swagger UI at `/docs` is not rate-limited and loads correctly

Level 3 (Deferred):
- Full frontend end-to-end test confirms no regressions with rate limits active
- Admin rate limit (120/minute) does not interfere with normal multi-page SPA navigation
- SSE streaming endpoint reconnection behavior unaffected by admin rate limits
</verification>

<success_criteria>
1. Sending 20 POST requests to / within 10 seconds succeeds; the 21st returns HTTP 429
2. /health/readiness without an API key returns `{"status": "ok", "timestamp": "..."}` only
3. /health/readiness with a valid X-API-Key header (matching AGENTED_API_KEY env var) returns full component health details
4. Health endpoint is exempt from rate limiting
5. All backend tests pass; frontend build succeeds
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/04-security-hardening/04-02-SUMMARY.md`
</output>
