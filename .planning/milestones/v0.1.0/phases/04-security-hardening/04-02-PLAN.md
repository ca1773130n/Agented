---
phase: 04-security-hardening
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/routes/__init__.py
  - backend/app/routes/health.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "Sending 20 POST requests to / within 10 seconds succeeds; the 21st returns HTTP 429 with a JSON error body"
    - "GitHub webhook endpoint (/api/webhooks/github/) has a rate limit of 30 requests per minute"
    - "Admin routes have a rate limit of 120 requests per minute per IP"
    - "Health and docs blueprints are exempt from rate limiting"
    - "GET /health/readiness without authentication returns only {status, timestamp} — no execution IDs, process PIDs, CLIProxy ports, or startup warnings"
    - "GET /health/readiness with authentication (via Phase 3 auth mechanism) returns full component health details"
  artifacts:
    - path: "backend/app/routes/__init__.py"
      provides: "Blueprint-level rate limit application and exemptions"
      contains: "limiter"
    - path: "backend/app/routes/health.py"
      provides: "Conditional health endpoint redaction for unauthenticated callers"
      contains: "authenticated"
  key_links:
    - from: "backend/app/routes/__init__.py"
      to: "backend/app/__init__.py"
      via: "app.extensions['limiter'] access"
      pattern: "app.extensions.*limiter"
    - from: "backend/app/routes/health.py"
      to: "flask.g"
      via: "auth status check"
      pattern: "g\\.authenticated|is_authenticated"
---

<objective>
Apply per-blueprint rate limits to webhook and admin routes, exempt health and docs from rate limiting, and redact sensitive fields from the health readiness endpoint for unauthenticated callers.

Purpose: Complete SEC-02 (rate limiting enforcement) and SEC-03 (health endpoint redaction) by wiring the Limiter instance from Plan 01 to specific blueprints and adding conditional response logic to the readiness probe.

Output: Updated `register_blueprints()` with rate limit decorators and exemptions; updated `readiness()` with auth-conditional response redaction.

Research basis: flask-limiter blueprint-level limits (Context7 /alisaifee/flask-limiter); OWASP API Security Top 10 (2023) API3:2023 for minimum-data responses to unauthenticated callers.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/04-security-hardening/04-RESEARCH.md
@.planning/milestones/v0.1.0/phases/04-security-hardening/04-01-PLAN.md
</execution_context>

<context>
@.planning/milestones/v0.1.0/ROADMAP.md
@backend/app/routes/__init__.py
@backend/app/routes/health.py
@backend/app/routes/webhook.py
@backend/app/routes/github_webhook.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply blueprint-level rate limits and exemptions in register_blueprints()</name>
  <files>backend/app/routes/__init__.py</files>
  <action>
    Modify `register_blueprints()` in `backend/app/routes/__init__.py` to apply rate limits using the Limiter instance stored on `app.extensions["limiter"]` by Plan 01.

    **After all `app.register_api(...)` calls but before the SPA catch-all registration**, add:

    ```python
    # --- Rate limiting (SEC-02) ---
    # Retrieve limiter from app extensions (initialized in create_app)
    limiter = app.extensions.get("limiter")
    if limiter:
        # Webhook ingestion: 20 requests per 10 seconds per IP
        # Success criteria: 21st request within 10s returns HTTP 429
        limiter.limit("20/10seconds")(webhook_bp)

        # GitHub webhook: 30 requests per minute per IP
        limiter.limit("30/minute")(github_webhook_bp)

        # Admin routes: 120 requests per minute per IP
        # Generous limit to accommodate SPA page loads, AJAX calls, and SSE reconnects
        # (See 04-RESEARCH.md Pitfall 4: tight limits break SSE EventSource reconnect)
        admin_blueprints = [
            triggers_bp, audit_bp, utility_bp, executions_bp, pr_reviews_bp,
            agents_bp, agent_conversations_bp, skills_bp, teams_bp,
            products_bp, projects_bp, plugins_bp, marketplace_bp,
            settings_bp, hooks_bp, commands_bp, rules_bp,
            skill_conversations_bp, plugin_conversations_bp,
            hook_conversations_bp, command_conversations_bp,
            rule_conversations_bp, backends_bp, orchestration_bp,
            budgets_bp, plugin_exports_bp, monitoring_bp, scheduler_bp,
            setup_bp, super_agents_bp, super_agent_exports_bp,
            workflows_bp, sketches_bp, grd_bp, rotation_bp,
            mcp_servers_bp, project_mcp_bp, product_owner_bp,
        ]
        for bp in admin_blueprints:
            limiter.limit("120/minute")(bp)

        # Exempt health and docs from rate limiting
        # (04-RESEARCH.md: health probes must always respond; docs makes multiple XHR requests to load OpenAPI spec)
        limiter.exempt(health_bp)
    ```

    **IMPORTANT:** The `if limiter:` guard ensures tests that do not initialize the limiter (e.g., unit tests using a bare Flask app) do not crash.

    **Key pitfall to avoid (from 04-RESEARCH.md Pitfall 4):** Admin rate limit is set to 120/minute (2/second) which accommodates normal SPA usage including SSE reconnects. Do NOT set tighter limits (e.g., 10/minute) as this would break the frontend after brief network interruptions.

    **Key pitfall to avoid (from 04-RESEARCH.md):** Do NOT rate-limit the docs endpoint. Swagger UI makes multiple XHR requests to load the OpenAPI spec, and a strict limit would break it. The docs are served by flask-openapi3's internal blueprint which is separate from the explicitly registered blueprints. Since `default_limits=[]` (no global default) and we only apply limits to explicit blueprints, docs are inherently exempt.
  </action>
  <verify>
    Run the backend and execute a burst test (Level 2: Proxy):
    ```bash
    # Send 21 rapid POST requests to the webhook endpoint
    for i in $(seq 1 21); do
      STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -d '{}' http://localhost:20000/)
      echo "Request $i: HTTP $STATUS"
    done
    ```
    Requests 1-20 should return 200 (or 400 for empty payload — either is fine, NOT 429).
    Request 21 should return 429.

    Verify the 429 response is JSON (Level 2: Proxy):
    ```bash
    # After exhausting the limit:
    curl -s -X POST -H "Content-Type: application/json" -d '{}' http://localhost:20000/ | python -m json.tool
    ```
    Should output: `{"error": "Rate limit exceeded: ..."}` (not HTML).

    Verify health endpoint is NOT rate-limited (Level 1: Sanity):
    ```bash
    for i in $(seq 1 25); do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:20000/health/liveness; done
    ```
    All 25 should return 200 (never 429).

    Run `cd backend && uv run pytest` — all tests pass (Level 1: Sanity).
  </verify>
  <done>
    Webhook endpoint rate-limited at 20/10seconds per IP.
    GitHub webhook rate-limited at 30/minute per IP.
    All admin blueprints rate-limited at 120/minute per IP.
    Health blueprint exempt from rate limiting.
    429 response is JSON format.
    All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Redact sensitive fields from health readiness for unauthenticated callers</name>
  <files>backend/app/routes/health.py</files>
  <action>
    Modify the `readiness()` function in `backend/app/routes/health.py` to return a minimal response when the caller is not authenticated.

    **Add imports:**
    ```python
    from datetime import datetime, timezone
    from flask import g
    ```

    **At the start of `readiness()`, check authentication status and return minimal response if unauthenticated:**

    ```python
    @health_bp.get("/readiness")
    def readiness():
        """Readiness probe with system health details.

        Unauthenticated callers receive a minimal response (SEC-03).
        Authenticated callers receive full component health details.
        """
        # SEC-03: Unauthenticated callers get minimal response
        # Phase 3 auth middleware sets g.authenticated = True for valid API keys.
        # If Phase 3 is not yet deployed, g.authenticated will not exist,
        # and ALL callers get the redacted response (safe default).
        is_authenticated = getattr(g, "authenticated", False)

        if not is_authenticated:
            return {
                "status": "ok",
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }, 200

        # Full response for authenticated callers (existing logic below)
        ...
    ```

    **Keep the entire existing readiness logic** (DB check, process manager check, CLIProxy check, startup warnings) inside the authenticated branch. The full existing code from line 20 onward (`from ..database import get_connection` through `return health, status_code`) stays but is only reached when `is_authenticated` is True.

    **Explicitly: the unauthenticated response MUST NOT contain:**
    - `active_execution_ids` (execution IDs are sensitive — reveal ongoing work)
    - `active_executions` (process count)
    - CLIProxy `port` number
    - Startup `warnings` (may contain internal paths, service names, error messages)
    - `components` object (any of it)

    The unauthenticated response MUST contain ONLY:
    - `"status": "ok"` (fixed string — does not reveal actual component status)
    - `"timestamp"`: current UTC time in ISO 8601 format

    **Leave the liveness endpoint unchanged.** `/health/liveness` returns `("", 200)` with no body — it's already minimal and does not expose any sensitive data.
  </action>
  <verify>
    Test unauthenticated response (Level 1: Sanity):
    ```bash
    curl -s http://localhost:20000/health/readiness | python -m json.tool
    ```
    Should return ONLY `{"status": "ok", "timestamp": "2026-..."}`.
    Must NOT contain `active_execution_ids`, `components`, `warnings`, `port`, or `active_executions`.

    Test authenticated response (Level 2: Proxy — requires Phase 3 auth to be deployed):
    ```bash
    curl -s -H "X-API-Key: <valid-key>" http://localhost:20000/health/readiness | python -m json.tool
    ```
    Should return full component health details (database, process_manager, cli_proxy, startup).

    Note: If Phase 3 auth middleware is not yet deployed, `g.authenticated` will always be False, and ALL callers will get the redacted response. This is the safe default per SEC-03. Once Phase 3 is deployed, authenticated callers will automatically start seeing full details.

    Verify liveness still works (Level 1: Sanity):
    ```bash
    curl -s -o /dev/null -w "%{http_code}" http://localhost:20000/health/liveness
    ```
    Should return 200.

    Run `cd backend && uv run pytest` — all tests pass (Level 1: Sanity).
    Run `just build` — frontend build succeeds (Level 1: Sanity).
  </verify>
  <done>
    /health/readiness returns minimal {status, timestamp} for unauthenticated callers.
    /health/readiness returns full component health for authenticated callers (when Phase 3 auth is active).
    No execution IDs, process PIDs, CLIProxy ports, or startup warnings exposed to unauthenticated callers.
    /health/liveness unchanged and functional.
    All backend tests pass. Frontend build succeeds.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run pytest` passes with zero failures
- `just build` succeeds (vue-tsc + vite)
- `/health/liveness` returns 200
- `/health/readiness` without auth returns only `status` and `timestamp` keys

Level 2 (Proxy):
- 20 rapid `POST /` requests succeed; 21st returns HTTP 429 with JSON body
- 429 response body is `{"error": "Rate limit exceeded: ..."}` (not HTML)
- `/health/readiness` without auth response contains no `active_execution_ids`, `components`, `warnings`, or `port`
- Health endpoint is never rate-limited (25 rapid requests all return 200)
- Swagger UI at `/docs` is not rate-limited and loads correctly

Level 3 (Deferred):
- Full frontend end-to-end test confirms no regressions with rate limits active
- Admin rate limit (120/minute) does not interfere with normal multi-page SPA navigation
- SSE streaming endpoint reconnection behavior unaffected by admin rate limits
- Authenticated /health/readiness returns full component details (requires Phase 3)
</verification>

<success_criteria>
1. Sending 20 POST requests to / within 10 seconds succeeds; the 21st returns HTTP 429
2. /health/readiness without an API key returns `{"status": "ok", "timestamp": "..."}` only
3. Health endpoint is exempt from rate limiting
4. All backend tests pass; frontend build succeeds
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/04-security-hardening/04-02-SUMMARY.md`
</output>
