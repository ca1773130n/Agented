---
phase: 02-environment-and-wsgi-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/run.py
  - backend/app/__init__.py
  - backend/gunicorn.conf.py
  - .gitignore
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "pyproject.toml lists gevent>=24.10.1, python-dotenv>=1.0.0, APScheduler>=3.10.0, and pytz>=2023.3 as dependencies"
    - "uv sync completes without errors and gevent, python-dotenv, APScheduler, pytz are importable"
    - "run.py calls load_dotenv() before create_app() so .env values are available to the app factory"
    - "SECRET_KEY is loaded from environment variable first, then .secret_key file, then generated and persisted — never auto-regenerated on restart"
    - "gunicorn.conf.py exists with workers=1, worker_class='gevent', and a comment explaining the single-worker constraint"
    - ".gitignore includes .env and .secret_key entries"
  artifacts:
    - path: "backend/gunicorn.conf.py"
      provides: "Gunicorn configuration for gevent worker deployment"
      contains: "worker_class"
    - path: "backend/pyproject.toml"
      provides: "Updated dependency list with gevent, python-dotenv, APScheduler, pytz"
      contains: "gevent"
    - path: "backend/run.py"
      provides: "Development entry point with dotenv loading"
      contains: "load_dotenv"
    - path: "backend/app/__init__.py"
      provides: "App factory with stable SECRET_KEY persistence"
      contains: "_get_secret_key"
  key_links:
    - from: "backend/run.py"
      to: "backend/app/__init__.py"
      via: "load_dotenv() runs before create_app()"
      pattern: "load_dotenv.*create_app"
    - from: "backend/gunicorn.conf.py"
      to: "backend/run.py"
      via: "wsgi_app references run:application"
      pattern: "wsgi_app.*run:application"
    - from: "backend/app/__init__.py"
      to: "backend/.secret_key"
      via: "_get_secret_key reads/writes .secret_key file"
      pattern: "_get_secret_key"
---

<objective>
Add gevent and python-dotenv dependencies, implement SECRET_KEY persistence, create gunicorn.conf.py, and wire dotenv loading into both the development and production entry points.

Purpose: Establish the dependency foundation and configuration infrastructure that all subsequent deployment work (justfile, process supervisor, .env.example) builds upon.
Output: Working gunicorn.conf.py, updated pyproject.toml with all missing deps, stable SECRET_KEY logic, dotenv integration in run.py.
Research basis: Research 02-RESEARCH.md Recommendations 1-4 — Gunicorn + gevent for SSE, python-dotenv for .env loading, SECRET_KEY persistence with fallback, accept default monkey.patch_all().
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/02-environment-and-wsgi-foundation/02-RESEARCH.md
</execution_context>

<context>
@.planning/codebase/STACK.md
@.planning/codebase/CONCERNS.md
@backend/pyproject.toml
@backend/run.py
@backend/app/__init__.py
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing dependencies to pyproject.toml and install</name>
  <files>backend/pyproject.toml</files>
  <action>
    Add the following dependencies to the `dependencies` list in `backend/pyproject.toml`:
    - `"gevent>=24.10.1"` — Required by Gunicorn 25.x GeventWorker for async SSE support (02-RESEARCH.md Recommendation 1)
    - `"python-dotenv>=1.0.0"` — Load .env files per 12-factor app pattern (02-RESEARCH.md Recommendation 2). Already available as transitive dep but must be explicit.
    - `"APScheduler>=3.10.0"` — Background scheduler already used by SchedulerService but missing from pyproject.toml (only in requirements.txt). See 02-RESEARCH.md Pitfall 1.
    - `"pytz>=2023.3"` — Required by APScheduler for timezone handling; already imported by SchedulerService.

    Add them after the existing `"cryptography>=41.0.0"` entry, maintaining the existing formatting.

    After editing pyproject.toml, run `cd backend && uv sync` to install all dependencies.

    Verify imports work:
    ```bash
    cd backend && uv run python -c "import gevent; import dotenv; import apscheduler; import pytz; print('All imports OK')"
    ```

    Do NOT remove requirements.txt in this plan — that is a separate concern.
  </action>
  <verify>
    1. `cd backend && uv sync` completes with exit code 0 (Level 1: Sanity)
    2. `cd backend && uv run python -c "import gevent; import dotenv; import apscheduler; import pytz; print('OK')"` prints "OK" (Level 1: Sanity)
    3. pyproject.toml contains all four new dependency lines (Level 1: Sanity)
  </verify>
  <done>
    pyproject.toml has gevent, python-dotenv, APScheduler, and pytz as explicit dependencies. All four are importable after uv sync. No existing dependencies removed or modified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SECRET_KEY persistence and dotenv loading in app factory and entry point</name>
  <files>backend/app/__init__.py, backend/run.py, .gitignore</files>
  <action>
    **Step A — Update backend/app/__init__.py:**

    Add a `_get_secret_key()` helper function before `create_app()` that implements the three-tier SECRET_KEY loading strategy (02-RESEARCH.md Recommendation 3, Pattern 2):

    ```python
    from pathlib import Path

    def _get_secret_key() -> str:
        """Load SECRET_KEY from env, persisted file, or generate and persist.

        Priority:
        1. SECRET_KEY environment variable (set in .env or shell)
        2. .secret_key file in backend/ directory (auto-generated on first run)
        3. Generate new key, persist to .secret_key, return it
        """
        # 1. Environment variable (highest priority)
        key = os.environ.get("SECRET_KEY")
        if key:
            return key

        # 2. Persisted file fallback
        key_file = Path(__file__).parent.parent / ".secret_key"
        if key_file.exists():
            stored = key_file.read_text().strip()
            if stored:
                return stored

        # 3. Generate and persist for future restarts
        key = secrets.token_hex(32)
        try:
            key_file.write_text(key)
            key_file.chmod(0o600)  # Owner-readable only
        except OSError:
            pass  # Fallback: ephemeral key (not ideal but won't crash)
        return key
    ```

    Then change the `SECRET_KEY` assignment in `create_app()` from:
    ```python
    SECRET_KEY=os.environ.get("SECRET_KEY") or secrets.token_hex(32),
    ```
    to:
    ```python
    SECRET_KEY=_get_secret_key(),
    ```

    Add `from pathlib import Path` to the imports at the top of the file. The `os` and `secrets` imports already exist.

    **Step B — Update backend/run.py:**

    Add `load_dotenv()` at the very top of the file, BEFORE any app imports. This ensures .env values are available when `create_app()` runs (02-RESEARCH.md Pattern 1, Pitfall 5):

    After the shebang and docstring, before any other imports, add:
    ```python
    from dotenv import load_dotenv
    load_dotenv()  # Load .env before anything else — override=False by default
    ```

    This MUST come before `from app import create_app` and before `logging.basicConfig()`.

    Also update the module-level `application = create_app()` line — keep it as-is; `load_dotenv()` above ensures env vars are loaded before it runs.

    **Step C — Update .gitignore:**

    Add entries for `.env` and `.secret_key` to the `.gitignore` file. Add them under a new "# Environment / secrets" section after the existing "# Runtime" section:

    ```
    # Environment / secrets
    .env
    backend/.secret_key
    ```

    **AVOID:**
    - Do NOT set `preload_app = True` anywhere (02-RESEARCH.md Pitfall 3)
    - Do NOT change the signal handlers or atexit registration in run.py
    - Do NOT modify any logic in create_app() beyond the SECRET_KEY line
  </action>
  <verify>
    1. `cd backend && uv run python -c "from app import create_app; app = create_app(); print(len(app.config['SECRET_KEY']))"` prints "64" (hex of 32 bytes) (Level 1: Sanity)
    2. Run the above twice — both invocations produce the same SECRET_KEY value (persisted to .secret_key) (Level 1: Sanity)
    3. `grep "load_dotenv" backend/run.py` shows load_dotenv() call before create_app import (Level 1: Sanity)
    4. `grep -E "\.env|\.secret_key" .gitignore` shows both entries present (Level 1: Sanity)
    5. `cd backend && uv run pytest` — all existing tests still pass (Level 1: Sanity)
  </verify>
  <done>
    SECRET_KEY persists across restarts via .secret_key file fallback. load_dotenv() runs before app factory in run.py. .gitignore prevents committing .env and .secret_key. All existing tests pass with no regressions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create gunicorn.conf.py with gevent worker configuration</name>
  <files>backend/gunicorn.conf.py</files>
  <action>
    Create `backend/gunicorn.conf.py` with the following content (02-RESEARCH.md Recommendation 1, Pattern 3, Code Example):

    ```python
    """Gunicorn configuration for Agented backend.

    workers=1 is MANDATORY until in-memory SSE state is migrated to Redis.
    The following services store state in class-level dicts or module globals
    that are NOT shared across processes:
    - ExecutionLogService._subscribers (SSE event delivery)
    - ProcessManager._processes (subprocess lifecycle tracking)
    - AgentMessageBusService._subscribers (agent SSE streams)
    - SchedulerService._scheduler (APScheduler job registry)
    - MonitoringService session tracking
    - Rate-limit retry state in ExecutionService

    With workers>1, each worker has independent copies of this state, causing
    SSE subscriptions to miss events and rate-limit detection to be invisible
    across workers. See .planning/codebase/CONCERNS.md Section 7.2.
    """

    from dotenv import load_dotenv
    load_dotenv()

    import os

    # Server socket
    bind = os.environ.get("GUNICORN_BIND", "0.0.0.0:20000")

    # Worker processes — see module docstring for why this MUST be 1
    workers = 1

    # Gevent worker class for async SSE support.
    # Allows the single worker to handle many concurrent long-lived SSE
    # connections via cooperative greenlet scheduling.
    # Gunicorn's GeventWorker calls monkey.patch_all() before loading the app,
    # which transparently converts threading.Thread/Lock to greenlets and
    # subprocess.Popen to a cooperative version.
    worker_class = "gevent"

    # Max concurrent greenlets per worker
    worker_connections = 1000

    # Timeout for worker response (seconds).
    # Long timeout to accommodate SSE streams and long-running AI executions
    # (Claude CLI subprocess can run for several minutes).
    timeout = 300

    # Graceful timeout — time to finish in-flight requests after SIGTERM
    graceful_timeout = 30

    # Do NOT set preload_app = True. With gevent workers, monkey patching
    # happens post-fork in GeventWorker.patch(). preload_app loads the app
    # in the master process BEFORE monkey patching, causing unpatched module
    # references. See 02-RESEARCH.md Pitfall 3.

    # Logging
    accesslog = "-"  # stdout
    errorlog = "-"   # stderr
    loglevel = os.environ.get("LOG_LEVEL", "info")

    # WSGI application — references the `application` object in run.py
    wsgi_app = "run:application"
    ```

    Ensure the file is placed at `backend/gunicorn.conf.py` (same level as `run.py`).

    **AVOID:**
    - Do NOT set `preload_app = True` (02-RESEARCH.md Pitfall 3 — breaks monkey patching order)
    - Do NOT set `workers > 1` (in-memory state constraint documented in CONCERNS.md 7.2)
    - Do NOT add `--reload` flag in the config file — that belongs in dev invocations only
  </action>
  <verify>
    1. `test -f backend/gunicorn.conf.py && echo "exists"` prints "exists" (Level 1: Sanity)
    2. `cd backend && uv run python -c "exec(open('gunicorn.conf.py').read()); assert workers == 1; assert worker_class == 'gevent'; print('Config OK')"` prints "Config OK" (Level 1: Sanity)
    3. `grep -c "preload_app" backend/gunicorn.conf.py` shows 0 (or only in a comment) — preload_app is NOT set as a config value (Level 1: Sanity)
    4. `cd backend && uv run gunicorn --check-config -c gunicorn.conf.py` exits with code 0 (Level 1: Sanity)
  </verify>
  <done>
    gunicorn.conf.py exists at backend/gunicorn.conf.py with workers=1, worker_class='gevent', and a detailed comment explaining the single-worker constraint. preload_app is not set. Gunicorn config check passes.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity) — all checks for this plan:
1. `cd backend && uv sync` succeeds
2. `cd backend && uv run python -c "import gevent; import dotenv; import apscheduler; import pytz"` succeeds
3. SECRET_KEY is identical across two consecutive create_app() calls (persisted to .secret_key)
4. `cd backend && uv run gunicorn --check-config -c gunicorn.conf.py` exits 0
5. `grep "load_dotenv" backend/run.py` matches
6. `grep -E "\.env|\.secret_key" .gitignore` matches both entries
7. `cd backend && uv run pytest` passes with no regressions
8. `cd frontend && npm run build` passes (no frontend changes, but confirm no breakage)
</verification>

<success_criteria>
All four missing dependencies (gevent, python-dotenv, APScheduler, pytz) are installable via uv sync and importable. SECRET_KEY persists across server restarts via .secret_key file fallback. gunicorn.conf.py is valid and enforces workers=1 with gevent. run.py loads .env before creating the Flask app. .gitignore prevents committing secrets.
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/02-environment-and-wsgi-foundation/02-01-SUMMARY.md`
</output>
