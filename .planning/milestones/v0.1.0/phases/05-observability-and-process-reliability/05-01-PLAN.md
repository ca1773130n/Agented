---
phase: 05-observability-and-process-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/logging_config.py
  - backend/app/middleware.py
  - backend/run.py
  - backend/gunicorn.conf.py
  - backend/pyproject.toml
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "pyproject.toml lists python-json-logger>=3.2.0 as a dependency and uv sync installs it without errors"
    - "Every application log line emitted during an API request is valid JSON containing timestamp, level, logger, message, and request_id fields"
    - "All log lines for a single API request share the same request_id UUID value"
    - "The X-Request-ID response header is present on every HTTP response and matches the request_id in log output"
    - "Background tasks (APScheduler jobs) emit log lines with request_id set to null, not a stale UUID from a previous request"
    - "Setting LOG_FORMAT=text reverts to human-readable plaintext logging format"
    - "Gunicorn access logging is disabled (accesslog = None) to avoid garbled mixed-format output"
  artifacts:
    - path: "backend/app/logging_config.py"
      provides: "JSON logging configuration with RequestIdFilter and configure_logging()"
      contains: "RequestIdFilter"
    - path: "backend/app/middleware.py"
      provides: "Flask before_request/after_request hooks for request ID lifecycle and request logging"
      contains: "init_request_middleware"
    - path: "backend/run.py"
      provides: "Entry point with configure_logging() replacing logging.basicConfig()"
      contains: "configure_logging"
    - path: "backend/gunicorn.conf.py"
      provides: "Gunicorn config with accesslog disabled"
      contains: "accesslog"
  key_links:
    - from: "backend/run.py"
      to: "backend/app/logging_config.py"
      via: "configure_logging() called before create_app()"
      pattern: "from app.logging_config import configure_logging"
    - from: "backend/app/middleware.py"
      to: "backend/app/logging_config.py"
      via: "Middleware reads/writes request_id_var ContextVar"
      pattern: "from .logging_config import request_id_var"
    - from: "backend/app/__init__.py"
      to: "backend/app/middleware.py"
      via: "create_app() calls init_request_middleware(app)"
      pattern: "init_request_middleware"
---

<objective>
Implement structured JSON logging with request ID correlation on every log line, using python-json-logger and a contextvars-based logging.Filter.

Purpose: Enable machine-parseable log output with per-request traceability. Every log line during an API request will carry the same request_id UUID, making it possible to grep logs for a specific request and see its complete lifecycle. This satisfies OBS-01.
Output: logging_config.py module, middleware.py module, updated run.py and gunicorn.conf.py.
Research basis: 05-RESEARCH.md Recommendations 1-2 — python-json-logger v3.x JsonFormatter with RequestIdFilter using contextvars.ContextVar for request ID propagation.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/05-observability-and-process-reliability/05-RESEARCH.md
</execution_context>

<context>
@.planning/codebase/STACK.md
@.planning/codebase/CONCERNS.md
@backend/run.py
@backend/gunicorn.conf.py
@backend/pyproject.toml
@backend/app/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add python-json-logger dependency and create logging_config.py with RequestIdFilter</name>
  <files>backend/pyproject.toml, backend/app/logging_config.py</files>
  <action>
    1. Add `"python-json-logger>=3.2.0"` to the `dependencies` list in `backend/pyproject.toml`.
    2. Run `cd backend && uv sync` to install the new dependency.
    3. Create `backend/app/logging_config.py` with the following components (based on python-json-logger cookbook + contextvars pattern from 05-RESEARCH.md):

    a) `request_id_var: ContextVar[str | None]` — module-level ContextVar with default=None. This is the single source of truth for the current request's ID.

    b) `class RequestIdFilter(logging.Filter)` — A filter that reads `request_id_var.get()` and assigns it to `record.request_id`. CRITICAL: This filter must NEVER call any logging function (infinite recursion — see 05-RESEARCH.md Pitfall from Common Implementation Traps). It must only read the ContextVar and assign to the record.

    c) `def configure_logging(log_level: str = "INFO", log_format: str = "json") -> None` — Configures the root logger:
       - Clears existing handlers (`root.handlers.clear()`)
       - Sets level from `log_level` parameter
       - If `log_format == "json"`: creates `StreamHandler` with `pythonjsonlogger.json.JsonFormatter` (v3 import path, NOT v2's `pythonjsonlogger.jsonlogger.JsonFormatter`). Format string: `"%(asctime)s %(levelname)s %(name)s %(message)s %(request_id)s"`, datefmt: `"%Y-%m-%dT%H:%M:%S"`
       - If `log_format != "json"`: creates `StreamHandler` with standard `logging.Formatter` using `"%(asctime)s [%(levelname)s] %(name)s: %(message)s"` (matches current format)
       - Attaches `RequestIdFilter()` to the root logger (works for both JSON and text modes — text mode just ignores the extra field)

    AVOID: Do NOT use structlog (requires replacing 90+ getLogger calls). Do NOT use the v2 import path `pythonjsonlogger.jsonlogger`. Do NOT log inside the filter.
  </action>
  <verify>
    cd backend && uv run python -c "from app.logging_config import configure_logging, request_id_var, RequestIdFilter; configure_logging(); print('OK')" (Level 1: Sanity)
    cd backend && uv run python -c "from pythonjsonlogger.json import JsonFormatter; print('import OK')" (Level 1: Sanity)
  </verify>
  <done>
    python-json-logger installed and importable. logging_config.py exports configure_logging(), request_id_var, and RequestIdFilter. configure_logging() produces JSON-formatted log output with request_id field. LOG_FORMAT=text falls back to plaintext format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create request ID middleware and wire into run.py and gunicorn.conf.py</name>
  <files>backend/app/middleware.py, backend/app/__init__.py, backend/run.py, backend/gunicorn.conf.py</files>
  <action>
    1. Create `backend/app/middleware.py` with `init_request_middleware(app)` function (based on 05-RESEARCH.md Pattern 2):

    a) `@app.before_request` handler `set_request_id()`:
       - Read incoming `X-Request-ID` header (honor upstream load balancer/proxy IDs)
       - If no header, generate `str(uuid.uuid4())`
       - Call `request_id_var.set(rid)` to store in contextvars
       - Also store in `g.request_id` for template/response access

    b) `@app.after_request` handler `log_request(response)`:
       - Add `X-Request-ID` header to response from `g.request_id`
       - Log the request lifecycle: method, path, status_code, and content_length using `logging.getLogger("app.request").info(...)`. This replaces Gunicorn's access log with a JSON-formatted request log line.
       - Return response

    c) `@app.teardown_request` handler `clear_request_id(exc)`:
       - Call `request_id_var.set(None)` for defense-in-depth against greenlet context leakage (05-RESEARCH.md Pitfall 1)

    2. In `backend/app/__init__.py`, inside `create_app()`, AFTER blueprint registration and BEFORE error handlers:
       - Add `from .middleware import init_request_middleware` and call `init_request_middleware(app)`
       - This must be called unconditionally (not gated by `testing`) so tests also get request ID support

    3. In `backend/run.py`:
       - Replace the `logging.basicConfig(...)` block (lines 16-20) with:
         ```python
         from app.logging_config import configure_logging
         configure_logging(
             log_level=os.environ.get("LOG_LEVEL", "INFO"),
             log_format=os.environ.get("LOG_FORMAT", "json"),
         )
         ```
       - The `import os` is already present (line 13). Ensure `configure_logging()` is called AFTER `load_dotenv()` (line 6) so env vars are available, and BEFORE `create_app()` (line 25).

    4. In `backend/gunicorn.conf.py`:
       - Change `accesslog = "-"` to `accesslog = None` — disables Gunicorn's native access log. Request logging is now handled by the after_request middleware in JSON format, preventing garbled mixed-format output (05-RESEARCH.md Pitfall 2).
       - Add a comment: `# Disabled: request lifecycle logged by app middleware in JSON format (see middleware.py)`

    AVOID: Do NOT initialize request_id_var inside the filter or middleware module-level code with a UUID (it should default to None). Do NOT use threading.local (use contextvars per 05-RESEARCH.md Recommendation 2). Do NOT keep Gunicorn accesslog enabled — it will produce garbled mixed JSON/plaintext output.
  </action>
  <verify>
    1. cd backend && uv run pytest (Level 1: Sanity — existing tests still pass)
    2. Start the backend with `cd backend && LOG_FORMAT=json uv run python run.py &`, then:
       - `curl -s -D- http://localhost:20000/health/readiness 2>/dev/null | grep X-Request-ID` — verify header is present (Level 2: Proxy)
       - Check stderr/stdout for JSON log lines containing "request_id" field with a UUID value (Level 2: Proxy)
       - Kill the server
    3. cd backend && uv run python -c "from app.middleware import init_request_middleware; print('import OK')" (Level 1: Sanity)
  </verify>
  <done>
    Every API response includes X-Request-ID header. All log lines during a request are JSON with a consistent request_id UUID. Gunicorn access log is disabled. LOG_FORMAT=text produces readable plaintext. Background tasks log with request_id=null.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run python -c "from app.logging_config import configure_logging; configure_logging(); print('OK')"` — module imports and configures without error
- `cd backend && uv run pytest` — all existing tests pass

Level 2 (Proxy):
- Start server, make API call, verify X-Request-ID header in response
- Grep log output for the returned X-Request-ID UUID — all log lines for that request share the same value
- Make two API calls — verify they have DIFFERENT request_id values (no leakage)
- Set LOG_FORMAT=text, restart server, verify plaintext format
- Trigger an APScheduler job (wait for scheduled execution), verify its log lines have request_id: null

Level 3 (Deferred):
- Load test with concurrent requests — verify no request ID cross-contamination under greenlet concurrency
</verification>

<success_criteria>
1. Every application log line during an HTTP request is valid JSON with request_id, timestamp, level, logger, and message fields
2. All log lines for a single request share the same request_id UUID (verified by grepping for the UUID returned in X-Request-ID header)
3. LOG_FORMAT=text produces human-readable plaintext without JSON wrapping
4. Background tasks (APScheduler) log with request_id=null
5. cd backend && uv run pytest passes with zero failures
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/05-observability-and-process-reliability/05-01-SUMMARY.md`
</output>
