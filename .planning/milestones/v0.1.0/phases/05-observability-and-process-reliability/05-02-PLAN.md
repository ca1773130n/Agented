---
phase: 05-observability-and-process-reliability
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/run.py
  - backend/pyproject.toml
  - backend/.env.example
autonomous: true
verification_level: proxy

user_setup:
  - service: sentry
    why: "Error tracking and performance monitoring — required for OBS-02 verification"
    env_vars:
      - name: SENTRY_DSN
        source: "sentry.io -> Project Settings -> Client Keys (DSN)"
    dashboard_config:
      - task: "Create a Sentry project for Agented"
        location: "sentry.io -> Projects -> Create Project -> Python/Flask"

must_haves:
  truths:
    - "pyproject.toml lists sentry-sdk[flask]>=2.0.0 as a dependency and uv sync installs it without errors"
    - "When SENTRY_DSN is set, sentry_sdk.init() is called with the DSN before create_app() in run.py"
    - "When SENTRY_DSN is not set (empty string or absent), Sentry initialization is a no-op and the server starts normally"
    - "Deliberately triggering an unhandled exception results in the error appearing in the Sentry dashboard within 60 seconds"
    - "SSE streaming endpoints (/stream, /sessions/) do not create Sentry performance transactions (filtered by before_send_transaction)"
    - ".env.example documents SENTRY_DSN, SENTRY_TRACES_SAMPLE_RATE, SENTRY_ENVIRONMENT, and SENTRY_RELEASE with descriptions"
  artifacts:
    - path: "backend/run.py"
      provides: "Entry point with Sentry SDK initialization guarded by SENTRY_DSN env var"
      contains: "sentry_sdk.init"
    - path: "backend/pyproject.toml"
      provides: "Updated dependency list with sentry-sdk[flask]"
      contains: "sentry-sdk"
    - path: "backend/.env.example"
      provides: "Environment variable documentation including Sentry configuration"
      contains: "SENTRY_DSN"
  key_links:
    - from: "backend/run.py"
      to: "sentry-sdk"
      via: "sentry_sdk.init() called at module level with FlaskIntegration auto-detection"
      pattern: "sentry_sdk.init"
    - from: "backend/run.py"
      to: "backend/app/__init__.py"
      via: "Sentry init happens BEFORE create_app() so Flask integration attaches to the app"
      pattern: "sentry_sdk.init.*create_app"
---

<objective>
Integrate Sentry SDK for automatic error tracking and performance monitoring, with SSE endpoint filtering and environment-guarded initialization.

Purpose: Capture unhandled exceptions with full request context (URL, headers, breadcrumbs, stack traces) and surface them in the Sentry dashboard. This provides production error visibility without requiring log monitoring. Satisfies OBS-02.
Output: Updated run.py with Sentry init block, updated pyproject.toml with sentry-sdk dependency, updated .env.example with Sentry env vars.
Research basis: 05-RESEARCH.md Recommendation 3 — sentry-sdk[flask] >= 2.0 with FlaskIntegration auto-detect, module-level init in run.py, SSE transaction filtering via before_send_transaction.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/05-observability-and-process-reliability/05-RESEARCH.md
@.planning/milestones/v0.1.0/phases/05-observability-and-process-reliability/05-01-SUMMARY.md
</execution_context>

<context>
@backend/run.py
@backend/pyproject.toml
@backend/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sentry-sdk dependency and implement Sentry initialization in run.py</name>
  <files>backend/pyproject.toml, backend/run.py</files>
  <action>
    1. Add `"sentry-sdk[flask]>=2.0.0"` to the `dependencies` list in `backend/pyproject.toml`.
    2. Run `cd backend && uv sync` to install the new dependency.
    3. In `backend/run.py`, AFTER the `configure_logging()` call (added by Plan 05-01) and BEFORE `from app import create_app`, add the Sentry initialization block (based on 05-RESEARCH.md Recommendation 3 and Pattern 3):

    ```python
    import sentry_sdk

    _sentry_dsn = os.environ.get("SENTRY_DSN", "")
    if _sentry_dsn:
        def _filter_sse_transactions(event, hint):
            """Drop Sentry transactions for long-lived SSE streaming endpoints.

            SSE endpoints keep connections open for minutes, creating extremely
            long-duration transactions that distort performance metrics and
            consume Sentry quota. See 05-RESEARCH.md Pitfall 5.
            """
            tx = event.get("transaction", "")
            if "/stream" in tx or "sessions/" in tx:
                return None
            return event

        sentry_sdk.init(
            dsn=_sentry_dsn,
            traces_sample_rate=float(os.environ.get("SENTRY_TRACES_SAMPLE_RATE", "0.1")),
            environment=os.environ.get("SENTRY_ENVIRONMENT", "production"),
            release=os.environ.get("SENTRY_RELEASE", "agented@0.1.0"),
            send_default_pii=False,
            before_send_transaction=_filter_sse_transactions,
        )
    ```

    CRITICAL placement notes (from 05-RESEARCH.md):
    - Sentry init MUST happen AFTER load_dotenv() so SENTRY_DSN is available from .env
    - Sentry init MUST happen BEFORE create_app() so FlaskIntegration auto-detects the Flask app
    - With preload_app=False (our Gunicorn config), run.py is loaded fresh in each worker AFTER gevent monkey patching. Module-level init is correct. Do NOT initialize in post_fork() or post_worker_init().
    - When SENTRY_DSN is empty string, the entire block is skipped — Sentry is a no-op. Local dev works without a Sentry account.

    AVOID: Do NOT import sentry_sdk at module level in any service file (05-RESEARCH.md Common Implementation Traps). Do NOT use post_fork initialization. Do NOT set send_default_pii=True (privacy concern). Do NOT initialize inside create_app() — it must happen before Flask app creation.
  </action>
  <verify>
    1. cd backend && uv run python -c "import sentry_sdk; print('sentry-sdk imported OK')" (Level 1: Sanity)
    2. cd backend && uv run python -c "from run import application; print('app created OK')" — verify no errors when SENTRY_DSN is unset (Level 1: Sanity)
    3. cd backend && uv run pytest (Level 1: Sanity — existing tests pass)
  </verify>
  <done>
    sentry-sdk[flask] installed. run.py calls sentry_sdk.init() when SENTRY_DSN is set, skips when unset. SSE transactions filtered via before_send_transaction. Server starts cleanly with and without SENTRY_DSN.
  </done>
</task>

<task type="auto">
  <name>Task 2: Document Sentry environment variables in .env.example</name>
  <files>backend/.env.example</files>
  <action>
    Add the following Sentry configuration section to `backend/.env.example`, placed AFTER the `# --- Server ---` section and BEFORE the `# --- CORS ---` section (or as a new `# --- Error Tracking ---` section):

    ```
    # --- Error Tracking (Sentry) ---
    # Sentry DSN for error tracking (string, no default — Sentry disabled when unset)
    # Get your DSN from: sentry.io -> Project Settings -> Client Keys (DSN)
    # SENTRY_DSN=

    # Sentry performance transaction sampling rate (float 0.0-1.0, default: 0.1)
    # 0.1 = sample 10% of requests for performance monitoring
    # SENTRY_TRACES_SAMPLE_RATE=0.1

    # Sentry environment tag (string, default: production)
    # SENTRY_ENVIRONMENT=production

    # Sentry release tag (string, default: agented@0.1.0)
    # SENTRY_RELEASE=agented@0.1.0
    ```

    Also add a `# --- Logging ---` section if not already present (Plan 05-01 may have added LOG_FORMAT):

    ```
    # --- Logging ---
    # Log output format: json for structured JSON, text for human-readable (string, default: json)
    # LOG_FORMAT=json
    ```

    Verify that LOG_FORMAT is documented. If Plan 05-01 already added it, do not duplicate.
  </action>
  <verify>
    grep -c "SENTRY_DSN" backend/.env.example — returns 1+ (Level 1: Sanity)
    grep -c "SENTRY_TRACES_SAMPLE_RATE" backend/.env.example — returns 1+ (Level 1: Sanity)
    grep -c "LOG_FORMAT" backend/.env.example — returns 1+ (Level 1: Sanity)
  </verify>
  <done>
    .env.example documents all Sentry env vars (SENTRY_DSN, SENTRY_TRACES_SAMPLE_RATE, SENTRY_ENVIRONMENT, SENTRY_RELEASE) and LOG_FORMAT with descriptions, defaults, and instructions.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run python -c "import sentry_sdk; print('OK')"` — sentry-sdk is importable
- `cd backend && uv run pytest` — all existing tests pass
- Server starts without errors when SENTRY_DSN is not set

Level 2 (Proxy):
- Set SENTRY_DSN to a valid test project DSN. Start the server.
- Trigger an unhandled exception (e.g., raise an error in a test route). Verify the event appears in the Sentry dashboard within 60 seconds.
- Open an SSE endpoint (/admin/executions/{id}/stream). Verify no Sentry transaction is created for it.
- Verify Sentry captures request context (URL, method, headers) on error events.

Level 3 (Deferred):
- Tune SENTRY_TRACES_SAMPLE_RATE based on production traffic volume
- Verify Sentry event deduplication under rapid error bursts
</verification>

<success_criteria>
1. sentry-sdk[flask] installed and server starts with and without SENTRY_DSN
2. Unhandled exceptions appear in Sentry dashboard within 60 seconds when DSN is configured
3. SSE streaming endpoints do not create Sentry performance transactions
4. .env.example documents all Sentry environment variables
5. cd backend && uv run pytest passes with zero failures
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/05-observability-and-process-reliability/05-02-SUMMARY.md`
</output>
