---
phase: 03-api-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/package.json
  - frontend/src/services/api/client.ts
  - frontend/src/services/api/triggers.ts
  - frontend/src/services/api/agents.ts
  - frontend/src/services/api/plugins.ts
  - frontend/src/services/api/hooks.ts
  - frontend/src/services/api/commands.ts
  - frontend/src/services/api/rules.ts
  - frontend/src/services/api/skills.ts
  - frontend/src/services/api/super-agents.ts
  - frontend/src/services/api/workflows.ts
  - frontend/src/services/api/grd.ts
  - frontend/src/components/super-agents/MessageInbox.vue
  - frontend/src/components/projects/InteractiveSetup.vue
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "apiFetch() includes X-API-Key header on every REST request when key is configured in localStorage"
    - "All SSE connections use @microsoft/fetch-event-source with X-API-Key header instead of native EventSource"
    - "SSE wrapper preserves existing backoff, reconnection, and backpressure queue behavior"
    - "SSE wrapper does NOT retry on 401 (fatal error — prevents infinite retry loop)"
    - "Frontend build (vue-tsc + vite) succeeds with zero type errors"
    - "All frontend tests pass"
  artifacts:
    - path: "frontend/src/services/api/client.ts"
      provides: "apiFetch with X-API-Key header + createAuthenticatedEventSource wrapper"
      contains: "X-API-Key"
    - path: "frontend/package.json"
      provides: "@microsoft/fetch-event-source dependency"
      contains: "fetch-event-source"
  key_links:
    - from: "frontend/src/services/api/client.ts"
      to: "localStorage agented-api-key"
      via: "getApiKey() reads from localStorage"
      pattern: "localStorage.*agented-api-key"
    - from: "frontend/src/services/api/triggers.ts"
      to: "frontend/src/services/api/client.ts"
      via: "imports createAuthenticatedEventSource"
      pattern: "createAuthenticatedEventSource"
    - from: "frontend/src/services/api/agents.ts"
      to: "frontend/src/services/api/client.ts"
      via: "imports createAuthenticatedEventSource"
      pattern: "createAuthenticatedEventSource"
---

<objective>
Add API key header to all frontend REST and SSE requests, replacing native EventSource with @microsoft/fetch-event-source for authenticated streaming.

Purpose: Complete the frontend half of API authentication — ensure every request from the browser includes the X-API-Key header, including SSE streams which native EventSource cannot authenticate (MDN Web Docs, W3C spec limitation). This is the entangled counterpart to Plan 01's backend auth middleware; deploying backend auth without this plan would silently break all SSE streams (03-RESEARCH.md Pitfall 1).

Output: Modified `apiFetch()` with auth header injection, new `createAuthenticatedEventSource()` wrapper using `@microsoft/fetch-event-source`, all 13 SSE consumer files migrated from `new EventSource()`.

Research basis: `@microsoft/fetch-event-source` (2.5k+ GitHub stars, Microsoft Azure) is the de facto standard for authenticated SSE (03-RESEARCH.md Recommendation 2). Eliminates query-string token complexity and log exposure risk (HAHWUL, "How to Securing SSE", 2025).
</objective>

<execution_context>
@.claude/agents/grd-executor.md
</execution_context>

<context>
@.planning/milestones/v0.1.0/ROADMAP.md
@.planning/milestones/v0.1.0/phases/03-api-authentication/03-RESEARCH.md
@.planning/milestones/v0.1.0/phases/03-api-authentication/03-01-SUMMARY.md
@frontend/src/services/api/client.ts
@frontend/src/services/api/triggers.ts
@frontend/src/services/api/agents.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fetch-event-source and add API key to apiFetch</name>
  <files>frontend/package.json, frontend/src/services/api/client.ts</files>
  <action>
    **Part A — Install @microsoft/fetch-event-source:**

    Run: `cd frontend && npm install @microsoft/fetch-event-source`

    This adds the single new dependency needed for authenticated SSE (03-RESEARCH.md Standard Stack).

    **Part B — Add API key header to apiFetch() in client.ts:**

    1. Add a `getApiKey()` helper function at the top of `client.ts` (after the constants, before `ApiError`):
       ```typescript
       /** Read the API key from localStorage for request authentication. */
       export function getApiKey(): string {
         return typeof window !== 'undefined'
           ? localStorage.getItem('agented-api-key') || ''
           : '';
       }
       ```
       The `typeof window` guard prevents SSR/test crashes in non-browser environments.

    2. In `apiFetchSingle()`, inject the API key into the headers object. Modify the headers construction (around line 55-58) to include `X-API-Key` when a key is configured:
       ```typescript
       const apiKey = getApiKey();
       const response = await fetch(`${API_BASE}${url}`, {
         ...fetchOptions,
         signal: controller.signal,
         headers: {
           'Content-Type': 'application/json',
           ...(apiKey ? { 'X-API-Key': apiKey } : {}),
           ...fetchOptions?.headers,
         },
       });
       ```
       Note: `fetchOptions?.headers` comes LAST so callers can override if needed.

    **Part C — Create createAuthenticatedEventSource() wrapper in client.ts:**

    Replace the existing `createBackoffEventSource()` function with a new `createAuthenticatedEventSource()` that uses `@microsoft/fetch-event-source`. The new wrapper must preserve ALL existing behavior:
    - Exponential backoff reconnection (SSE_INITIAL_DELAY_MS, SSE_MAX_DELAY_MS, SSE_MAX_ATTEMPTS)
    - Backpressure queue with drain batching (SSE_MAX_QUEUE_SIZE, SSE_DRAIN_BATCH_SIZE)
    - Queue overflow warnings and callbacks (onQueueOverflow)
    - Give-up callback after max attempts (onGiveUp)
    - Queue depth accessor for debugging
    - Pre-saturation warning at 75% queue capacity

    The new function signature:
    ```typescript
    export interface AuthenticatedEventSourceOptions {
      onGiveUp?: () => void;
      onQueueOverflow?: (dropCount: number) => void;
    }

    export interface AuthenticatedEventSource {
      readonly queueDepth: number;
      addEventListener(type: string, handler: EventListenerOrEventListenerObject): void;
      close(): void;
    }

    export function createAuthenticatedEventSource(
      url: string,
      options?: AuthenticatedEventSourceOptions
    ): AuthenticatedEventSource
    ```

    Implementation approach:
    1. Import `fetchEventSource` and `EventStreamContentType` from `@microsoft/fetch-event-source`.
    2. Create an `AbortController` for cancellation.
    3. Use `fetchEventSource(url, { headers: { 'X-API-Key': getApiKey() }, ... })`.
    4. In `onopen`: validate response.ok and content-type. On 401, throw a fatal error (do NOT retry — prevents infinite 401 loop per 03-RESEARCH.md Pitfall 5).
    5. In `onmessage`: route events through the backpressure queue (reuse queue logic from current createBackoffEventSource).
    6. In `onerror`: increment attempt counter, apply backoff delay, retry on transient errors. Stop after SSE_MAX_ATTEMPTS.
    7. Return an object with `addEventListener`, `close`, and `queueDepth` — matching the interface consumers expect.

    ALSO keep `createBackoffEventSource` as a deprecated re-export aliasing `createAuthenticatedEventSource` if any external consumers reference it, OR rename all call sites in the same task. Since `createBackoffEventSource` is only used in `triggers.ts`, it is safe to just update that call site in Task 2.

    Keep the existing `BackoffEventSource` and `BackoffEventSourceOptions` type exports for backward compatibility, but mark them as deprecated with JSDoc comments.

    AVOID: Using native `EventSource` anywhere in the new wrapper (it cannot send custom headers — MDN Web Docs). AVOID: Retrying on 401 (creates infinite loop — 03-RESEARCH.md Pitfall 5). AVOID: Passing API key as query parameter (appears in server logs — 03-RESEARCH.md anti-patterns).
  </action>
  <verify>
    cd frontend && npm run test:run (Level 1: Sanity — existing tests pass)
    cd frontend && npm run build (Level 1: Sanity — TypeScript compilation succeeds)

    Verify by reading code:
    - `getApiKey()` reads from `localStorage.getItem('agented-api-key')`
    - `apiFetchSingle()` includes `X-API-Key` in headers
    - `createAuthenticatedEventSource()` uses `fetchEventSource` (not `new EventSource`)
    - 401 handling throws fatal error (no retry)
    - Backpressure queue logic preserved
  </verify>
  <done>
    @microsoft/fetch-event-source installed in package.json, apiFetch sends X-API-Key header, createAuthenticatedEventSource wraps fetchEventSource with backoff + backpressure queue + auth header, 401 is fatal (no retry), frontend build and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate all SSE consumers from native EventSource to authenticated wrapper</name>
  <files>
    frontend/src/services/api/triggers.ts,
    frontend/src/services/api/agents.ts,
    frontend/src/services/api/plugins.ts,
    frontend/src/services/api/hooks.ts,
    frontend/src/services/api/commands.ts,
    frontend/src/services/api/rules.ts,
    frontend/src/services/api/skills.ts,
    frontend/src/services/api/super-agents.ts,
    frontend/src/services/api/workflows.ts,
    frontend/src/services/api/grd.ts,
    frontend/src/components/super-agents/MessageInbox.vue,
    frontend/src/components/projects/InteractiveSetup.vue
  </files>
  <action>
    Migrate every `new EventSource(url)` call in the frontend to use `createAuthenticatedEventSource()` from `client.ts`. There are 13 files with SSE usage (found via grep).

    **API service files (10 files):**

    For each of these files, replace `new EventSource(url)` with `createAuthenticatedEventSource(url)`:

    1. `triggers.ts` (line 237): Already uses `createBackoffEventSource`. Update import to `createAuthenticatedEventSource` and update the call site. Update the return type if needed.

    2. `agents.ts` (line 88): `new EventSource(...)` → `createAuthenticatedEventSource(...)`. Add import for `createAuthenticatedEventSource` from `./client`. Update return type from `EventSource` to `AuthenticatedEventSource`.

    3. `plugins.ts` (line 157): Same pattern as agents.ts.

    4. `hooks.ts` (line 68): Same pattern. Note this is an inline arrow function in an object literal.

    5. `commands.ts` (line 63): Same pattern as hooks.ts.

    6. `rules.ts` (line 72): Same pattern as hooks.ts.

    7. `skills.ts` (lines 37 and 134): Two SSE endpoints. Migrate both.

    8. `super-agents.ts` (lines 62 and 65): Two SSE endpoints. Migrate both.

    9. `workflows.ts` (line 56): One SSE endpoint. Migrate.

    10. `grd.ts` (lines 267 and 280): Two SSE endpoints. Note these use `/api/projects/...` paths (no `API_BASE` prefix in the URL string). Ensure the authenticated wrapper handles this correctly — `createAuthenticatedEventSource` should prepend `API_BASE` like `apiFetch` does.

    **Vue component files (2 files):**

    11. `components/super-agents/MessageInbox.vue` (line 78): Replace `new EventSource(...)` with `createAuthenticatedEventSource(...)`. Add import at the top of the `<script>` block.

    12. `components/projects/InteractiveSetup.vue` (line 68): Same pattern.

    **For each migration, the pattern is:**
    ```typescript
    // BEFORE:
    import { API_BASE } from './client';
    // ... somewhere in code:
    return new EventSource(`${API_BASE}/api/agents/conversations/${convId}/stream`);

    // AFTER:
    import { API_BASE, createAuthenticatedEventSource } from './client';
    // ... somewhere in code:
    return createAuthenticatedEventSource(`${API_BASE}/api/agents/conversations/${convId}/stream`);
    ```

    **Return type changes:** Functions that previously returned `EventSource` should now return `AuthenticatedEventSource` (imported from `./client`). Check each function's return type annotation and update accordingly. If there is no explicit return type, TypeScript will infer it.

    **Consumer compatibility:** The `createAuthenticatedEventSource` return object must support `addEventListener(type, handler)` and `close()` — these are the only methods used by SSE consumers in this codebase (verified by grep). The `onmessage`, `onopen`, `onerror` properties on native EventSource are NOT used by the consumers (they use `addEventListener` exclusively).

    IMPORTANT: Make sure every single `new EventSource(` in the frontend codebase is replaced. After migration, `grep -r "new EventSource" frontend/src/` should return ZERO results (only references in comments or the deprecated type export are acceptable).

    AVOID: Leaving any `new EventSource()` calls unmigrated (would silently fail with 401 after auth is enabled — 03-RESEARCH.md Pitfall 1).
  </action>
  <verify>
    cd frontend && npm run build (Level 2: Proxy — full TypeScript compilation catches type mismatches)
    cd frontend && npm run test:run (Level 1: Sanity — all tests pass)

    grep -r "new EventSource" frontend/src/ — should return zero results in .ts/.vue files (excluding comments)

    Level 2 (Proxy — manual verification):
    - Start backend with AGENTED_API_KEY set
    - Set key in browser localStorage: localStorage.setItem('agented-api-key', '<key>')
    - Open execution detail page, trigger a test run, confirm live log lines appear via SSE
    - Check browser DevTools network tab: all /admin/* and /api/* requests include X-API-Key header
  </verify>
  <done>
    All 13 files migrated from new EventSource() to createAuthenticatedEventSource(), zero remaining new EventSource calls in frontend/src/, frontend build succeeds with zero type errors, all frontend tests pass, SSE streams include X-API-Key header.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd frontend && npm run build` succeeds (vue-tsc + vite, catches all type errors)
- `cd frontend && npm run test:run` passes
- `grep -r "new EventSource" frontend/src/` returns zero matches in .ts/.vue files

Level 2 (Proxy):
- Browser DevTools: every /admin/* and /api/* request shows X-API-Key header
- SSE execution log stream delivers live events after setting localStorage key and AGENTED_API_KEY env var
- `curl http://localhost:20000/admin/triggers` without X-API-Key returns 401 (with AGENTED_API_KEY set)
- `curl -H "X-API-Key: $KEY" http://localhost:20000/admin/triggers` returns 200
- `curl -H "Origin: https://evil.example.com" http://localhost:20000/admin/triggers` has no Access-Control-Allow-Origin header

Level 3 (Deferred):
- Comprehensive test of all 20+ SSE endpoints post-migration
- Load testing concurrent SSE connections with auth enabled
- Key rotation behavior across active SSE streams
</verification>

<success_criteria>
1. `cd frontend && npm run build` exits 0
2. `cd frontend && npm run test:run` exits 0
3. `cd backend && uv run pytest` exits 0
4. No `new EventSource(` calls remain in frontend/src/ (all migrated to authenticated wrapper)
5. `apiFetch()` sends X-API-Key header from localStorage on every request
6. createAuthenticatedEventSource() uses fetchEventSource with X-API-Key header, backoff, and backpressure queue
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/03-api-authentication/03-02-SUMMARY.md`
</output>
