---
phase: 03-api-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/package.json
  - frontend/src/services/api/client.ts
  - frontend/src/services/api/triggers.ts
  - frontend/src/services/api/agents.ts
  - frontend/src/services/api/plugins.ts
  - frontend/src/services/api/hooks.ts
  - frontend/src/services/api/commands.ts
  - frontend/src/services/api/rules.ts
  - frontend/src/services/api/skills.ts
  - frontend/src/services/api/super-agents.ts
  - frontend/src/services/api/workflows.ts
  - frontend/src/services/api/grd.ts
  - frontend/src/components/super-agents/MessageInbox.vue
  - frontend/src/components/projects/InteractiveSetup.vue
  - frontend/src/composables/useWorkflowExecution.ts
  - frontend/src/composables/usePlanningSession.ts
  - frontend/src/composables/useConversation.ts
  - frontend/src/composables/useProjectSession.ts
  - frontend/src/composables/useAiChat.ts
  - frontend/src/views/WorkflowPlaygroundPage.vue
  - frontend/src/views/ProjectManagementPage.vue
  - frontend/src/views/SkillsPlayground.vue
  - frontend/src/components/triggers/ExecutionLogViewer.vue
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "apiFetch() includes X-API-Key header on every REST request when key is configured in localStorage"
    - "All SSE connections use @microsoft/fetch-event-source with X-API-Key header instead of native EventSource"
    - "SSE wrapper preserves existing backoff, reconnection, and backpressure queue behavior"
    - "SSE wrapper does NOT retry on 401 (fatal error — prevents infinite retry loop)"
    - "SSE wrapper supports onmessage/onerror/onopen property assignment (not just addEventListener) for consumer compatibility"
    - "Backend auth middleware returns 401 for protected routes without key, 200 with valid key, and bypasses auth for health/docs/webhooks (verified by curl)"
    - "Frontend build (vue-tsc + vite) succeeds with zero type errors"
    - "All frontend tests pass"
  artifacts:
    - path: "frontend/src/services/api/client.ts"
      provides: "apiFetch with X-API-Key header + createAuthenticatedEventSource wrapper"
      contains: "X-API-Key"
    - path: "frontend/package.json"
      provides: "@microsoft/fetch-event-source dependency"
      contains: "fetch-event-source"
  key_links:
    - from: "frontend/src/services/api/client.ts"
      to: "localStorage agented-api-key"
      via: "getApiKey() reads from localStorage"
      pattern: "localStorage.*agented-api-key"
    - from: "frontend/src/services/api/triggers.ts"
      to: "frontend/src/services/api/client.ts"
      via: "imports createAuthenticatedEventSource"
      pattern: "createAuthenticatedEventSource"
    - from: "frontend/src/services/api/agents.ts"
      to: "frontend/src/services/api/client.ts"
      via: "imports createAuthenticatedEventSource"
      pattern: "createAuthenticatedEventSource"
---

<objective>
Add API key header to all frontend REST and SSE requests, replacing native EventSource with @microsoft/fetch-event-source for authenticated streaming.

Purpose: Complete the frontend half of API authentication — ensure every request from the browser includes the X-API-Key header, including SSE streams which native EventSource cannot authenticate (MDN Web Docs, W3C spec limitation). This is the entangled counterpart to Plan 01's backend auth middleware; deploying backend auth without this plan would silently break all SSE streams (03-RESEARCH.md Pitfall 1).

Output: Modified `apiFetch()` with auth header injection, new `createAuthenticatedEventSource()` wrapper using `@microsoft/fetch-event-source`, all 13 SSE consumer files migrated from `new EventSource()`.

Research basis: `@microsoft/fetch-event-source` (2.5k+ GitHub stars, Microsoft Azure) is the de facto standard for authenticated SSE (03-RESEARCH.md Recommendation 2). Eliminates query-string token complexity and log exposure risk (HAHWUL, "How to Securing SSE", 2025).
</objective>

<execution_context>
@.claude/agents/grd-executor.md
</execution_context>

<context>
@.planning/milestones/v0.1.0/ROADMAP.md
@.planning/milestones/v0.1.0/phases/03-api-authentication/03-RESEARCH.md
@.planning/milestones/v0.1.0/phases/03-api-authentication/03-01-SUMMARY.md
@frontend/src/services/api/client.ts
@frontend/src/services/api/triggers.ts
@frontend/src/services/api/agents.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fetch-event-source and add API key to apiFetch</name>
  <files>frontend/package.json, frontend/src/services/api/client.ts</files>
  <action>
    **Part A — Install @microsoft/fetch-event-source:**

    Run: `cd frontend && npm install @microsoft/fetch-event-source`

    This adds the single new dependency needed for authenticated SSE (03-RESEARCH.md Standard Stack).

    **Part B — Add API key header to apiFetch() in client.ts:**

    1. Add a `getApiKey()` helper function at the top of `client.ts` (after the constants, before `ApiError`):
       ```typescript
       /** Read the API key from localStorage for request authentication. */
       export function getApiKey(): string {
         return typeof window !== 'undefined'
           ? localStorage.getItem('agented-api-key') || ''
           : '';
       }
       ```
       The `typeof window` guard prevents SSR/test crashes in non-browser environments.

    2. In `apiFetchSingle()`, inject the API key into the headers object. Modify the headers construction (around line 55-58) to include `X-API-Key` when a key is configured:
       ```typescript
       const apiKey = getApiKey();
       const response = await fetch(`${API_BASE}${url}`, {
         ...fetchOptions,
         signal: controller.signal,
         headers: {
           'Content-Type': 'application/json',
           ...(apiKey ? { 'X-API-Key': apiKey } : {}),
           ...fetchOptions?.headers,
         },
       });
       ```
       Note: `fetchOptions?.headers` comes LAST so callers can override if needed.

    **Part C — Create createAuthenticatedEventSource() wrapper in client.ts:**

    Replace the existing `createBackoffEventSource()` function with a new `createAuthenticatedEventSource()` that uses `@microsoft/fetch-event-source`. The new wrapper must preserve ALL existing behavior:
    - Exponential backoff reconnection (SSE_INITIAL_DELAY_MS, SSE_MAX_DELAY_MS, SSE_MAX_ATTEMPTS)
    - Backpressure queue with drain batching (SSE_MAX_QUEUE_SIZE, SSE_DRAIN_BATCH_SIZE)
    - Queue overflow warnings and callbacks (onQueueOverflow)
    - Give-up callback after max attempts (onGiveUp)
    - Queue depth accessor for debugging
    - Pre-saturation warning at 75% queue capacity

    The new function signature:
    ```typescript
    export interface AuthenticatedEventSourceOptions {
      onGiveUp?: () => void;
      onQueueOverflow?: (dropCount: number) => void;
    }

    export interface AuthenticatedEventSource {
      readonly queueDepth: number;
      addEventListener(type: string, handler: EventListenerOrEventListenerObject): void;
      close(): void;
      /** Settable callback for default message events (mirrors EventSource.onmessage). */
      onmessage: ((event: MessageEvent) => void) | null;
      /** Settable callback for connection errors (mirrors EventSource.onerror). */
      onerror: ((event: Event) => void) | null;
      /** Settable callback for connection open (mirrors EventSource.onopen). */
      onopen: ((event: Event) => void) | null;
    }

    export function createAuthenticatedEventSource(
      url: string,
      options?: AuthenticatedEventSourceOptions
    ): AuthenticatedEventSource
    ```

    **CRITICAL — Property-assignment compatibility for consumer files:**

    Multiple consumer files use `.onmessage =`, `.onerror =`, and `.onopen =` property assignment on the returned object (NOT `addEventListener`). The wrapper MUST support this. Specifically:
    - `.onmessage =` is used by: `useWorkflowExecution.ts`, `usePlanningSession.ts`, `WorkflowPlaygroundPage.vue`
    - `.onerror =` is used by: `useWorkflowExecution.ts`, `usePlanningSession.ts`, `useConversation.ts`, `useProjectSession.ts`, `WorkflowPlaygroundPage.vue`, `SkillsPlayground.vue`, `ExecutionLogViewer.vue`, `InteractiveSetup.vue`

    Implementation approach:
    1. Import `fetchEventSource` and `EventStreamContentType` from `@microsoft/fetch-event-source`.
    2. Create an `AbortController` for cancellation.
    3. Maintain internal `_onmessage`, `_onerror`, `_onopen` callback slots (initially null).
    4. Use `fetchEventSource(url, { headers: { 'X-API-Key': getApiKey() }, ... })`.
    5. In `onopen`: validate response.ok and content-type. On 401, throw a fatal error (do NOT retry — prevents infinite 401 loop per 03-RESEARCH.md Pitfall 5). Call `_onopen` if set.
    6. In `onmessage`: route events through the backpressure queue (reuse queue logic from current createBackoffEventSource). When draining the queue, invoke `_onmessage` for default message events (events with no custom type).
    7. In `onerror`: call `_onerror` if set, increment attempt counter, apply backoff delay, retry on transient errors. Stop after SSE_MAX_ATTEMPTS.
    8. Return an object with `addEventListener`, `close`, `queueDepth`, and settable `onmessage`/`onerror`/`onopen` properties — matching both the `addEventListener` and property-assignment patterns used by consumers.

    ALSO keep `createBackoffEventSource` as a deprecated re-export aliasing `createAuthenticatedEventSource` if any external consumers reference it, OR rename all call sites in the same task. Since `createBackoffEventSource` is only used in `triggers.ts`, it is safe to just update that call site in Task 2.

    Keep the existing `BackoffEventSource` and `BackoffEventSourceOptions` type exports for backward compatibility, but mark them as deprecated with JSDoc comments.

    AVOID: Using native `EventSource` anywhere in the new wrapper (it cannot send custom headers — MDN Web Docs). AVOID: Retrying on 401 (creates infinite loop — 03-RESEARCH.md Pitfall 5). AVOID: Passing API key as query parameter (appears in server logs — 03-RESEARCH.md anti-patterns).
  </action>
  <verify>
    cd frontend && npm run test:run (Level 1: Sanity — existing tests pass)
    cd frontend && npm run build (Level 1: Sanity — TypeScript compilation succeeds)

    Verify by reading code:
    - `getApiKey()` reads from `localStorage.getItem('agented-api-key')`
    - `apiFetchSingle()` includes `X-API-Key` in headers
    - `createAuthenticatedEventSource()` uses `fetchEventSource` (not `new EventSource`)
    - 401 handling throws fatal error (no retry)
    - Backpressure queue logic preserved
    - `AuthenticatedEventSource` interface includes settable `onmessage`, `onerror`, `onopen` properties
    - Implementation stores and invokes `_onmessage`/`_onerror`/`_onopen` callbacks when set via property assignment
  </verify>
  <done>
    @microsoft/fetch-event-source installed in package.json, apiFetch sends X-API-Key header, createAuthenticatedEventSource wraps fetchEventSource with backoff + backpressure queue + auth header, 401 is fatal (no retry), onmessage/onerror/onopen property-assignment callbacks work for consumer compatibility, frontend build and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate all SSE consumers from native EventSource to authenticated wrapper</name>
  <files>
    frontend/src/services/api/triggers.ts,
    frontend/src/services/api/agents.ts,
    frontend/src/services/api/plugins.ts,
    frontend/src/services/api/hooks.ts,
    frontend/src/services/api/commands.ts,
    frontend/src/services/api/rules.ts,
    frontend/src/services/api/skills.ts,
    frontend/src/services/api/super-agents.ts,
    frontend/src/services/api/workflows.ts,
    frontend/src/services/api/grd.ts,
    frontend/src/components/super-agents/MessageInbox.vue,
    frontend/src/components/projects/InteractiveSetup.vue,
    frontend/src/composables/useWorkflowExecution.ts,
    frontend/src/composables/usePlanningSession.ts,
    frontend/src/composables/useConversation.ts,
    frontend/src/composables/useProjectSession.ts,
    frontend/src/composables/useAiChat.ts,
    frontend/src/views/WorkflowPlaygroundPage.vue,
    frontend/src/views/ProjectManagementPage.vue,
    frontend/src/views/SkillsPlayground.vue,
    frontend/src/components/triggers/ExecutionLogViewer.vue
  </files>
  <action>
    Migrate every `new EventSource(url)` call in the frontend to use `createAuthenticatedEventSource()` from `client.ts`. There are 13 files with SSE usage (found via grep).

    **API service files (10 files):**

    For each of these files, replace `new EventSource(url)` with `createAuthenticatedEventSource(url)`:

    1. `triggers.ts` (line 237): Already uses `createBackoffEventSource`. Update import to `createAuthenticatedEventSource` and update the call site. Update the return type if needed.

    2. `agents.ts` (line 88): `new EventSource(...)` → `createAuthenticatedEventSource(...)`. Add import for `createAuthenticatedEventSource` from `./client`. Update return type from `EventSource` to `AuthenticatedEventSource`.

    3. `plugins.ts` (line 157): Same pattern as agents.ts.

    4. `hooks.ts` (line 68): Same pattern. Note this is an inline arrow function in an object literal.

    5. `commands.ts` (line 63): Same pattern as hooks.ts.

    6. `rules.ts` (line 72): Same pattern as hooks.ts.

    7. `skills.ts` (lines 37 and 134): Two SSE endpoints. Migrate both.

    8. `super-agents.ts` (lines 62 and 65): Two SSE endpoints. Migrate both.

    9. `workflows.ts` (line 56): One SSE endpoint. Migrate.

    10. `grd.ts` (lines 267 and 280): Two SSE endpoints. Note these use `/api/projects/...` paths (no `API_BASE` prefix in the URL string). Ensure the authenticated wrapper handles this correctly — `createAuthenticatedEventSource` should prepend `API_BASE` like `apiFetch` does.

    **Vue component files (2 files):**

    11. `components/super-agents/MessageInbox.vue` (line 78): Replace `new EventSource(...)` with `createAuthenticatedEventSource(...)`. Add import at the top of the `<script>` block.

    12. `components/projects/InteractiveSetup.vue` (line 68): Same pattern.

    **For each migration, the pattern is:**
    ```typescript
    // BEFORE:
    import { API_BASE } from './client';
    // ... somewhere in code:
    return new EventSource(`${API_BASE}/api/agents/conversations/${convId}/stream`);

    // AFTER:
    import { API_BASE, createAuthenticatedEventSource } from './client';
    // ... somewhere in code:
    return createAuthenticatedEventSource(`${API_BASE}/api/agents/conversations/${convId}/stream`);
    ```

    **Return type changes:** Functions that previously returned `EventSource` should now return `AuthenticatedEventSource` (imported from `./client`). Check each function's return type annotation and update accordingly. If there is no explicit return type, TypeScript will infer it.

    **Consumer compatibility:** The `createAuthenticatedEventSource` return object must support:
    - `addEventListener(type, handler)` and `close()` — used by most SSE consumers.
    - `onmessage`, `onerror`, and `onopen` settable properties — used by several consumers via property assignment. Specifically:
      - `.onmessage =` is used in: `useWorkflowExecution.ts` (line 45), `usePlanningSession.ts` (line 64), `WorkflowPlaygroundPage.vue` (line 91)
      - `.onerror =` is used in: `useWorkflowExecution.ts` (line 54), `usePlanningSession.ts` (line 133), `useConversation.ts` (line 175), `useProjectSession.ts` (line 168), `WorkflowPlaygroundPage.vue` (line 126), `SkillsPlayground.vue` (line 171), `ExecutionLogViewer.vue` (line 139), `InteractiveSetup.vue` (line 127)

    These consumers receive the EventSource object from the migrated API service functions. Because `AuthenticatedEventSource` (defined in Task 1) includes settable `onmessage`, `onerror`, and `onopen` properties, these property assignments will work correctly without modifying the consumer files.

    **Type annotation updates for consumer files:** Several consumer files declare their EventSource variable with an explicit `EventSource` type annotation (e.g., `let eventSource: EventSource | null = null`). After migration, the API service functions return `AuthenticatedEventSource` instead of `EventSource`. If TypeScript reports type errors on these variable declarations, update them to use `AuthenticatedEventSource | null` (imported from the service API module or client.ts). The affected files are:
    - `composables/useWorkflowExecution.ts` (line 23): `let eventSource: EventSource | null`
    - `composables/usePlanningSession.ts` (line 27): `let eventSource: EventSource | null`
    - `composables/useConversation.ts` (line 73): `const eventSourceRef = ref<EventSource | null>(null)`
    - `composables/useProjectSession.ts` (line 40): `let eventSource: EventSource | null`
    - `composables/useAiChat.ts` (line 54): `let eventSource: EventSource | null`
    - `views/WorkflowPlaygroundPage.vue` (line 52): `let chatEventSource: EventSource | null`
    - `views/ProjectManagementPage.vue` (line 43): `let chatEventSource: EventSource | null`
    - `components/super-agents/MessageInbox.vue` (line 24): `let eventSource: EventSource | null`
    - `components/projects/InteractiveSetup.vue` (line 31): `let eventSource: EventSource | null`
    - `views/SkillsPlayground.vue` (line 20): `const eventSource = ref<EventSource | null>(null)`
    - `components/triggers/ExecutionLogViewer.vue` (line 26): `const eventSource = ref<EventSource | null>(null)`

    Also update the `ConversationApi` interface in `composables/useConversation.ts` (line 16): change `stream: (convId: string) => EventSource` to `stream: (convId: string) => AuthenticatedEventSource`.

    These type annotation changes are necessary for `vue-tsc` to pass. The actual runtime behavior does not change — only the TypeScript types are updated to match the new return type.

    IMPORTANT: Make sure every single `new EventSource(` in the frontend codebase is replaced. After migration, `grep -r "new EventSource" frontend/src/` should return ZERO results (only references in comments or the deprecated type export are acceptable).

    AVOID: Leaving any `new EventSource()` calls unmigrated (would silently fail with 401 after auth is enabled — 03-RESEARCH.md Pitfall 1).
  </action>
  <verify>
    cd frontend && npm run build (Level 2: Proxy — full TypeScript compilation catches type mismatches)
    cd frontend && npm run test:run (Level 1: Sanity — all tests pass)

    grep -r "new EventSource" frontend/src/ — should return zero results in .ts/.vue files (excluding comments)

    Level 2 (Proxy — end-to-end auth verification with curl):

    Start the backend with AGENTED_API_KEY set and verify the middleware works:

    ```bash
    # Start backend with auth enabled
    cd backend && AGENTED_API_KEY=test-key-123 uv run python -m app &
    BACKEND_PID=$!
    sleep 2

    # 1. Protected route WITHOUT key → must return 401
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:20000/admin/triggers)
    [ "$HTTP_STATUS" = "401" ] && echo "PASS: 401 without key" || echo "FAIL: expected 401, got $HTTP_STATUS"

    # 2. Protected route WITH valid key → must return 200
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: test-key-123" http://127.0.0.1:20000/admin/triggers)
    [ "$HTTP_STATUS" = "200" ] && echo "PASS: 200 with valid key" || echo "FAIL: expected 200, got $HTTP_STATUS"

    # 3. Protected route WITH wrong key → must return 401
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: wrong-key" http://127.0.0.1:20000/admin/triggers)
    [ "$HTTP_STATUS" = "401" ] && echo "PASS: 401 with wrong key" || echo "FAIL: expected 401, got $HTTP_STATUS"

    # 4. Bypass route (health) → must return 200 without key
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:20000/health/)
    [ "$HTTP_STATUS" = "200" ] && echo "PASS: health bypasses auth" || echo "FAIL: expected 200, got $HTTP_STATUS"

    # 5. Bypass route (docs) → must return 200 without key
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:20000/docs/)
    [ "$HTTP_STATUS" = "200" ] && echo "PASS: docs bypasses auth" || echo "FAIL: expected 200, got $HTTP_STATUS"

    # Cleanup
    kill $BACKEND_PID 2>/dev/null
    ```

    All 5 checks must PASS. If any FAIL, the auth middleware is broken and Task 2 is not done.
  </verify>
  <done>
    All 13 API/component files migrated from new EventSource() to createAuthenticatedEventSource(), consumer type annotations updated (EventSource → AuthenticatedEventSource) in 11 composable/view/component files, ConversationApi interface updated, zero remaining new EventSource calls in frontend/src/, frontend build succeeds with zero type errors, all frontend tests pass, SSE streams include X-API-Key header, curl verification confirms 401 without key + 200 with valid key + bypass routes pass.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd frontend && npm run build` succeeds (vue-tsc + vite, catches all type errors)
- `cd frontend && npm run test:run` passes
- `grep -r "new EventSource" frontend/src/` returns zero matches in .ts/.vue files

Level 2 (Proxy):
- Browser DevTools: every /admin/* and /api/* request shows X-API-Key header
- SSE execution log stream delivers live events after setting localStorage key and AGENTED_API_KEY env var
- `curl http://localhost:20000/admin/triggers` without X-API-Key returns 401 (with AGENTED_API_KEY set)
- `curl -H "X-API-Key: $KEY" http://localhost:20000/admin/triggers` returns 200
- `curl -H "Origin: https://evil.example.com" http://localhost:20000/admin/triggers` has no Access-Control-Allow-Origin header

Level 3 (Deferred):
- Comprehensive test of all 20+ SSE endpoints post-migration
- Load testing concurrent SSE connections with auth enabled
- Key rotation behavior across active SSE streams
</verification>

<success_criteria>
1. `cd frontend && npm run build` exits 0
2. `cd frontend && npm run test:run` exits 0
3. `cd backend && uv run pytest` exits 0
4. No `new EventSource(` calls remain in frontend/src/ (all migrated to authenticated wrapper)
5. `apiFetch()` sends X-API-Key header from localStorage on every request
6. createAuthenticatedEventSource() uses fetchEventSource with X-API-Key header, backoff, and backpressure queue
7. createAuthenticatedEventSource() supports onmessage/onerror/onopen property assignment (consumer compatibility)
8. curl: `http://127.0.0.1:20000/admin/triggers` without key returns 401 (with AGENTED_API_KEY set)
9. curl: `http://127.0.0.1:20000/admin/triggers` with valid X-API-Key returns 200
10. curl: `http://127.0.0.1:20000/health/` without key returns 200 (bypass route)
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/03-api-authentication/03-02-SUMMARY.md`
</output>
