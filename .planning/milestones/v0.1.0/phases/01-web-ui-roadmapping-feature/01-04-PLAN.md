---
phase: 01-web-ui-roadmapping-feature
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/services/grd_planning_service.py
  - backend/app/services/grd_sync_service.py
  - backend/app/services/project_session_manager.py
  - backend/app/routes/projects.py
autonomous: true
verification_level: proxy

must_haves:
  truths:
    - "GrdPlanningService.auto_init_project() runs map-codebase then new-project sequentially in background"
    - "Background auto-init updates grd_init_status through none -> initializing -> ready (or failed)"
    - "Session-completion hook in ProjectSessionManager triggers GrdSyncService.sync_project() BEFORE broadcasting complete event"
    - "Project creation route (POST /admin/projects) triggers auto-init after clone completes"
    - "If .planning/ already exists in cloned repo, GrdSyncService.sync_project() runs immediately (no AI session needed)"
    - "Auto-init failure is captured and stored as grd_init_status='failed' — does not crash the server"
  artifacts:
    - path: "backend/app/services/grd_planning_service.py"
      provides: "auto_init_project method with sequential PTY session orchestration"
      contains: "auto_init_project"
    - path: "backend/app/services/grd_sync_service.py"
      provides: "Session-completion sync trigger integration"
      contains: "sync_on_session_complete"
    - path: "backend/app/routes/projects.py"
      provides: "Auto-init trigger in project creation flow"
      contains: "auto_init"
  key_links:
    - from: "backend/app/services/grd_planning_service.py"
      to: "backend/app/services/grd_sync_service.py"
      via: "sync call after init sessions complete"
      pattern: "GrdSyncService.sync_project"
    - from: "backend/app/services/grd_planning_service.py"
      to: "backend/app/db/projects.py"
      via: "grd_init_status updates"
      pattern: "update_project.*grd_init_status"
    - from: "backend/app/routes/projects.py"
      to: "backend/app/services/grd_planning_service.py"
      via: "auto-init trigger on project creation"
      pattern: "GrdPlanningService.auto_init"
---

<objective>
Implement background auto-initialization of GRD planning on project creation and session-completion-triggered database sync.

Purpose: When a user creates a project (with git clone), GRD planning infrastructure should be set up automatically in the background — mapping the codebase and initializing a new project. When any planning session completes, the `.planning/` files should be synced to the database before the frontend is notified, ensuring the UI always shows fresh data.

Output: `auto_init_project` method on GrdPlanningService, session-completion sync hook, auto-init trigger in project creation route.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-CONTEXT.md
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-RESEARCH.md
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-01-SUMMARY.md
@backend/app/services/grd_planning_service.py
@backend/app/services/grd_sync_service.py
@backend/app/services/project_session_manager.py
@backend/app/routes/projects.py
@backend/app/services/project_workspace_service.py
</execution_context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auto_init_project and session-completion sync</name>
  <files>backend/app/services/grd_planning_service.py, backend/app/services/grd_sync_service.py, backend/app/services/project_session_manager.py</files>
  <action>
    **Step 1: Add auto_init_project to GrdPlanningService** (`backend/app/services/grd_planning_service.py`)

    Add a new classmethod `auto_init_project(project_id: str, local_path: str)`:

    ```python
    @classmethod
    def auto_init_project(cls, project_id: str, local_path: str):
        """Background GRD initialization after project clone.

        Checks if .planning/ already exists. If so, syncs directly.
        If not, runs map-codebase then new-project via sequential PTY sessions.
        Updates grd_init_status throughout the process.
        """
        import threading

        def _run_init():
            try:
                update_project(project_id, grd_init_status="initializing")
                planning_dir = str(Path(local_path) / ".planning")

                # Case 1: .planning/ already exists — just sync
                if Path(planning_dir).is_dir():
                    logger.info("Project %s has existing .planning/, syncing directly", project_id)
                    GrdSyncService.sync_project(project_id, planning_dir)
                    update_project(project_id, grd_init_status="ready")
                    return

                # Case 2: No .planning/ — run map-codebase, then new-project
                logger.info("Project %s: starting GRD auto-init", project_id)

                # Step 1: map-codebase
                result1 = cls._run_init_session(
                    project_id, local_path,
                    ["claude", "-p", "/grd:map-codebase"]
                )
                if not result1:
                    update_project(project_id, grd_init_status="failed")
                    return

                # Step 2: new-project --auto @README.md
                result2 = cls._run_init_session(
                    project_id, local_path,
                    ["claude", "-p", "/grd:new-project --auto @README.md"]
                )
                if not result2:
                    update_project(project_id, grd_init_status="failed")
                    return

                # Step 3: Sync .planning/ to DB
                if Path(planning_dir).is_dir():
                    GrdSyncService.sync_project(project_id, planning_dir)

                update_project(project_id, grd_init_status="ready")
                logger.info("Project %s: GRD auto-init complete", project_id)

            except Exception as e:
                logger.error("GRD auto-init failed for project %s: %s", project_id, e, exc_info=True)
                try:
                    update_project(project_id, grd_init_status="failed")
                except Exception:
                    pass

        thread = threading.Thread(target=_run_init, daemon=True, name=f"grd-init-{project_id}")
        thread.start()
    ```

    Add a helper `_run_init_session(project_id, local_path, cmd) -> bool`:
    - Creates a PTY session via `get_handler("direct").start({...})` with `execution_mode="autonomous"`.
    - Waits for session completion by polling `ProjectSessionManager.get_session_info(session_id)` every 2 seconds (check `info["status"]` for `completed` or `failed`), with a timeout of 10 minutes.
    - Returns `True` if session completed with exit code 0, `False` otherwise.
    - Log the session outcome (success/failure) at INFO level.

    Import `Path` from `pathlib`, `time`, and `GrdSyncService` from the sibling module.

    **Step 2: Add session-completion sync hook** (`backend/app/services/grd_sync_service.py`)

    Add a new classmethod `sync_on_session_complete(project_id: str, session_id: str)`:

    ```python
    @classmethod
    def sync_on_session_complete(cls, project_id: str, session_id: str):
        """Sync .planning/ files to DB after a planning session completes.

        Called by ProjectSessionManager._handle_session_exit() for GRD-related sessions.
        Runs synchronously BEFORE the complete event is broadcast to ensure
        the frontend sees fresh data when it refreshes.
        """
        from ..database import get_project
        project = get_project(project_id)
        if not project:
            logger.warning("sync_on_session_complete: project %s not found", project_id)
            return

        local_path = project.get("local_path")
        if not local_path:
            return

        planning_dir = str(Path(local_path).expanduser().resolve() / ".planning")
        if not Path(planning_dir).is_dir():
            return

        try:
            result = cls.sync_project(project_id, planning_dir)
            logger.info(
                "Session-completion sync for project %s: synced=%d, skipped=%d",
                project_id, result["synced"], result["skipped"],
            )
        except Exception as e:
            logger.error("Session-completion sync failed for project %s: %s", project_id, e)
    ```

    **Step 3: Wire sync hook into ProjectSessionManager** (`backend/app/services/project_session_manager.py`)

    In the `_handle_session_exit()` method (the method that runs when a PTY session process exits):
    - After updating the session status in the DB but BEFORE broadcasting the `complete` SSE event.
    - Add a conditional sync trigger:
      ```python
      # Sync GRD .planning/ files to DB on session completion
      try:
          from .grd_sync_service import GrdSyncService
          project_id = info.get("project_id") or session_info.get("project_id")
          if project_id:
              GrdSyncService.sync_on_session_complete(project_id, session_id)
      except Exception as e:
          logger.warning("GRD sync on session complete failed: %s", e)
      ```
    - This runs synchronously before the complete event broadcast, addressing RESEARCH.md Pitfall 2: "Session Completion Race Condition with DB Sync."
    - Wrap in try/except so sync failures do not prevent the session from completing normally.

    Find the exact location in `_handle_session_exit()` by searching for the `complete` SSE event broadcast (look for `_broadcast` call with `"complete"` event type) and insert the sync call just above it.
  </action>
  <verify>
    cd backend && uv run pytest -x
    (Level 1: Sanity — existing tests pass)

    cd backend && uv run python -c "from app.services.grd_planning_service import GrdPlanningService; assert hasattr(GrdPlanningService, 'auto_init_project')"
    (Level 1: Sanity — method exists)

    cd backend && uv run python -c "from app.services.grd_sync_service import GrdSyncService; assert hasattr(GrdSyncService, 'sync_on_session_complete')"
    (Level 1: Sanity — method exists)
  </verify>
  <done>
    GrdPlanningService.auto_init_project() runs background GRD initialization with sequential PTY sessions.
    GrdSyncService.sync_on_session_complete() syncs .planning/ to DB after session exit.
    ProjectSessionManager._handle_session_exit() calls sync before broadcasting complete event.
    All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auto-init into project creation route</name>
  <files>backend/app/routes/projects.py</files>
  <action>
    Modify the `create_project()` route handler in `backend/app/routes/projects.py` to trigger GRD auto-initialization after project creation.

    **Changes:**

    1. Import `GrdPlanningService` at the top of the file:
       ```python
       from ..services.grd_planning_service import GrdPlanningService
       ```

    2. In the `create_project()` function, AFTER the existing clone logic (`ProjectWorkspaceService.clone_async(project_id)`), add a post-clone hook.

       The challenge: `clone_async` runs in a background thread, so the local_path may not be available immediately. There are two cases:

       **Case A: `local_path` provided directly** (no clone needed):
       - If `local_path` is provided in the request body (user pointed to an existing directory), trigger auto-init immediately:
         ```python
         if local_path and not github_repo:
             # Local path provided directly — init GRD immediately
             GrdPlanningService.auto_init_project(project_id, local_path)
         ```

       **Case B: GitHub repo provided** (clone happens async):
       - The clone runs in background via `ProjectWorkspaceService.clone_async(project_id)`.
       - We need to trigger auto-init AFTER clone completes. The cleanest approach: modify the response to include `grd_init_status: "pending"` and let the frontend poll via `getPlanningStatus()`, while adding a post-clone callback.
       - For now, add a simple approach: after `clone_async`, schedule a background check that waits for `clone_status == 'cloned'` and then triggers auto-init:
         ```python
         if github_repo:
             import threading

             def _wait_for_clone_and_init(pid, proj_id):
                 """Wait for clone to complete, then trigger GRD auto-init."""
                 import time
                 from ..database import get_project as _get_proj
                 for _ in range(120):  # Wait up to 4 minutes
                     time.sleep(2)
                     p = _get_proj(proj_id)
                     if not p:
                         return
                     status = p.get("clone_status", "none")
                     if status == "cloned":
                         lp = p.get("local_path")
                         if lp:
                             GrdPlanningService.auto_init_project(proj_id, lp)
                         return
                     if status == "failed":
                         return
                 # Timeout — don't init

             t = threading.Thread(
                 target=_wait_for_clone_and_init,
                 args=(project_id, project_id),
                 daemon=True,
                 name=f"grd-clone-wait-{project_id}",
             )
             t.start()
         ```

    3. Add `grd_init_status` to the response:
       ```python
       if github_repo:
           response["grd_init_status"] = "pending"
       elif local_path:
           response["grd_init_status"] = "initializing"
       ```

    IMPORTANT: All background work runs in daemon threads — server shutdown kills them. Failures are logged and stored via `grd_init_status = "failed"`, never propagated to the user's create request. Per RESEARCH.md Pitfall 4: "Background Auto-Init Failing Silently" — we store the status so the frontend can display it.
  </action>
  <verify>
    cd backend && uv run pytest -x
    (Level 1: Sanity — existing tests pass, no import errors)

    (Level 2: Proxy — manually create a project with a local_path and verify grd_init_status transitions from 'none' to 'initializing' in the DB)
  </verify>
  <done>
    Project creation triggers GRD auto-init. For local_path projects, init starts immediately. For GitHub projects, init starts after clone completes. grd_init_status tracks the process. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run pytest -x` passes
- GrdPlanningService.auto_init_project and GrdSyncService.sync_on_session_complete methods exist
- No import errors in projects.py route

Level 2 (Proxy):
- Create a project with local_path pointing to a directory with .planning/ — verify grd_init_status transitions to "ready"
- Create a project with local_path pointing to a directory WITHOUT .planning/ — verify grd_init_status transitions to "initializing"
- Run a planning session (via invoke endpoint), wait for completion, verify milestones/phases data is fresh in DB

Level 3 (Deferred):
- Full end-to-end: create project with GitHub repo, wait for clone + auto-init, verify Planning page shows milestones
- Concurrent auto-init for multiple projects (verify no SQLite locking issues)
</verification>

<success_criteria>
Auto-init runs in background after project creation. Session-completion sync runs before complete event is broadcast. grd_init_status tracks init lifecycle. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-04-SUMMARY.md`
</output>
