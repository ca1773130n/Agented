---
phase: 01-web-ui-roadmapping-feature
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/grd_planning_service.py
  - backend/app/db/schema.py
  - backend/app/db/migrations.py
  - backend/app/db/projects.py
  - backend/app/routes/grd.py
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "GrdPlanningService.invoke_command() creates a PTY session via ProjectSessionManager and returns a session_id"
    - "GrdPlanningService enforces single active planning session per project — second invocation returns error"
    - "projects table has grd_init_status column with values: none, initializing, ready, failed"
    - "update_project() accepts grd_init_status keyword argument"
    - "New backend endpoint POST /api/projects/<project_id>/planning/invoke accepts command name and args, returns session_id"
    - "New backend endpoint GET /api/projects/<project_id>/planning/status returns grd_init_status"
  artifacts:
    - path: "backend/app/services/grd_planning_service.py"
      provides: "GRD command dispatch via PTY sessions with single-session enforcement"
      min_lines: 80
    - path: "backend/app/db/migrations.py"
      provides: "Migration adding grd_init_status column to projects table"
      contains: "grd_init_status"
    - path: "backend/app/db/projects.py"
      provides: "update_project with grd_init_status parameter"
      contains: "grd_init_status"
    - path: "backend/app/routes/grd.py"
      provides: "Planning invoke and status endpoints"
      contains: "planning/invoke"
  key_links:
    - from: "backend/app/services/grd_planning_service.py"
      to: "backend/app/services/project_session_manager.py"
      via: "import and session creation"
      pattern: "from.*project_session_manager.*import.*ProjectSessionManager"
    - from: "backend/app/routes/grd.py"
      to: "backend/app/services/grd_planning_service.py"
      via: "import and invocation"
      pattern: "from.*grd_planning_service.*import.*GrdPlanningService"
---

<objective>
Create the backend GRD Planning Service and extend the database schema to support GRD planning sessions and initialization tracking.

Purpose: Establish the backend foundation for all GRD planning command invocations from the web UI. The service wraps PTY session creation with planning-specific logic (single-session enforcement, command construction, grd_init_status tracking). The new API endpoints allow the frontend to invoke any GRD planning command and check initialization status.

Output: `GrdPlanningService` class, `grd_init_status` DB column + migration, two new API endpoints on the GRD blueprint.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-CONTEXT.md
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-RESEARCH.md
@backend/app/services/project_session_manager.py
@backend/app/routes/grd.py
@backend/app/db/projects.py
@backend/app/db/schema.py
@backend/app/db/migrations.py
</execution_context>

<tasks>

<task type="auto">
  <name>Task 1: Create GrdPlanningService with command dispatch and single-session enforcement</name>
  <files>backend/app/services/grd_planning_service.py</files>
  <action>
    Create `backend/app/services/grd_planning_service.py` with a `GrdPlanningService` class following the existing classmethod pattern used throughout the codebase (see `GrdSyncService`, `ExecutionLogService`).

    The service must implement:

    1. **`invoke_command(project_id: str, command: str, args: dict = None) -> dict`**
       - Looks up the project via `get_project(project_id)` to get `local_path`.
       - Returns `{"error": "..."}` if project not found or has no `local_path`.
       - Checks for an existing active planning session for this project (query `get_sessions_by_project` and filter for `status='active'` and `execution_type='grd_planning'`). If one exists, return `{"error": "Planning session already active", "session_id": existing_id}`.
       - Builds the command: `cmd = ["claude", "-p", prompt]` where `prompt` is constructed as `/grd:{command}` with optional args appended (e.g., `/grd:plan-phase 1`). For commands requiring interactive input (e.g., `discuss-phase`), the prompt is just `/grd:{command}` with args; the PTY session handles interaction.
       - Creates a PTY session via the existing `create_session` endpoint pattern: call the execution type handler's `start()` method with `execution_type="grd_planning"` (reuse "direct" handler since that's what creates PTY sessions). Build the session config dict:
         ```python
         session_config = {
             "project_id": project_id,
             "cmd": cmd,
             "cwd": local_path,
             "execution_type": "direct",
             "execution_mode": "interactive",
         }
         ```
         Use `get_handler("direct")` from `execution_type_handler.py` and call `handler.start(session_config)`.
       - Returns `{"session_id": result["session_id"], "status": "running"}` on success.

    2. **`get_active_planning_session(project_id: str) -> Optional[str]`**
       - Returns the session_id of any active planning session for the project, or None.
       - Queries `get_sessions_by_project(project_id)` and filters for `status='active'`.

    3. **`get_init_status(project_id: str) -> str`**
       - Returns the `grd_init_status` field from the project record, defaulting to `"none"`.

    Per CONTEXT.md locked decision: "No reimplementation of GRD logic in Python. GRD commands execute within an AI session (Claude Code + GRD plugin)." This service ONLY manages session lifecycle — it does NOT call grd-tools.js or parse GRD files directly.

    Use `import logging; logger = logging.getLogger(__name__)` for logging.
    Import from `..database` following the pattern in `grd.py` routes.
    Import `get_handler` from `..services.execution_type_handler`.
  </action>
  <verify>
    cd backend && uv run python -c "from app.services.grd_planning_service import GrdPlanningService; print('Import OK')"
    (Level 1: Sanity — module imports without error)
  </verify>
  <done>GrdPlanningService class exists with invoke_command, get_active_planning_session, and get_init_status methods. All imports resolve. Single-session enforcement logic prevents concurrent planning sessions per project.</done>
</task>

<task type="auto">
  <name>Task 2: Add grd_init_status column, update DB functions, and create planning API endpoints</name>
  <files>backend/app/db/schema.py, backend/app/db/migrations.py, backend/app/db/projects.py, backend/app/routes/grd.py</files>
  <action>
    **Step 1: Schema update** (`backend/app/db/schema.py`)
    - Add `grd_init_status TEXT DEFAULT 'none'` column to the `projects` CREATE TABLE statement, after the `clone_error` column. Valid values: `none`, `initializing`, `ready`, `failed`.

    **Step 2: Migration** (`backend/app/db/migrations.py`)
    - Add a new migration entry in `init_db()` that adds the `grd_init_status` column to existing projects tables:
      ```python
      try:
          conn.execute("ALTER TABLE projects ADD COLUMN grd_init_status TEXT DEFAULT 'none'")
      except Exception:
          pass  # Column already exists
      ```
    - Follow the existing pattern of try/except for idempotent ALTER TABLE statements already used in `migrations.py`.

    **Step 3: DB function update** (`backend/app/db/projects.py`)
    - Add `grd_init_status: str = None` parameter to `update_project()`.
    - Add the corresponding SQL update clause:
      ```python
      if grd_init_status is not None:
          updates.append("grd_init_status = ?")
          values.append(grd_init_status)
      ```

    **Step 4: Planning API endpoints** (`backend/app/routes/grd.py`)
    - Add a new Pydantic model `InvokePlanningBody`:
      ```python
      class InvokePlanningBody(BaseModel):
          command: str = Field(..., description="GRD command name (e.g., plan-phase, discuss-phase)")
          args: Optional[dict] = Field(None, description="Command arguments as key-value pairs")
      ```
    - Add `POST /<project_id>/planning/invoke` endpoint:
      - Calls `GrdPlanningService.invoke_command(project_id, body.command, body.args)`.
      - Returns the result dict (either `{session_id, status}` or `{error}` with appropriate HTTP status).
    - Add `GET /<project_id>/planning/status` endpoint:
      - Returns `{"grd_init_status": project.get("grd_init_status", "none"), "active_session_id": active_session_or_none}`.
    - Import `GrdPlanningService` at the top of the routes file alongside existing service imports.

    Follow the exact patterns for Pydantic path/body models and HTTPStatus returns used in the existing GRD routes.
  </action>
  <verify>
    cd backend && uv run pytest -x
    (Level 1: Sanity — all existing tests pass, no regressions from schema/migration changes)
  </verify>
  <done>
    projects table has grd_init_status column. update_project() supports grd_init_status. Two new endpoints exist: POST /api/projects/{id}/planning/invoke and GET /api/projects/{id}/planning/status. Backend test suite passes.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd backend && uv run python -c "from app.services.grd_planning_service import GrdPlanningService"` succeeds
- `cd backend && uv run pytest -x` passes with zero failures
- `just build` succeeds (no frontend impact from backend-only changes)

Level 2 (Proxy):
- Start dev backend and call `curl -X POST http://localhost:20000/api/projects/{id}/planning/invoke -H "Content-Type: application/json" -d '{"command": "map-codebase"}'` — returns a session_id or meaningful error
- Call `GET /api/projects/{id}/planning/status` — returns `{"grd_init_status": "none", "active_session_id": null}`
</verification>

<success_criteria>
GrdPlanningService module exists and exports a class with invoke_command, get_active_planning_session, and get_init_status methods. The projects table has grd_init_status column. Two new API endpoints are available. All backend tests pass.
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-01-SUMMARY.md`
</output>
