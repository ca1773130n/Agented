---
phase: 01-web-ui-roadmapping-feature
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/composables/usePlanningSession.ts
  - frontend/src/services/api/grd.ts
  - frontend/src/services/api/types.ts
  - frontend/src/router/routes/projects.ts
autonomous: true
verification_level: sanity

must_haves:
  truths:
    - "usePlanningSession composable manages session lifecycle: invoke, stream SSE, send input, track status"
    - "grdApi has invokePlanningCommand() and getPlanningStatus() methods matching backend endpoints"
    - "Route /projects/:projectId/planning exists and lazy-loads ProjectPlanningPage.vue"
    - "usePlanningSession exposes reactive refs: sessionId, outputLines, status, currentQuestion"
    - "SSE event handlers parse output and complete events from ProjectSessionManager stream"
  artifacts:
    - path: "frontend/src/composables/usePlanningSession.ts"
      provides: "Planning session lifecycle composable with SSE streaming"
      min_lines: 100
    - path: "frontend/src/services/api/grd.ts"
      provides: "Extended grdApi with planning invoke and status methods"
      contains: "invokePlanningCommand"
    - path: "frontend/src/router/routes/projects.ts"
      provides: "Planning page route definition"
      contains: "project-planning"
  key_links:
    - from: "frontend/src/composables/usePlanningSession.ts"
      to: "frontend/src/services/api/grd.ts"
      via: "import and API calls"
      pattern: "import.*grdApi.*from"
    - from: "frontend/src/router/routes/projects.ts"
      to: "frontend/src/views/ProjectPlanningPage.vue"
      via: "lazy import"
      pattern: "import.*ProjectPlanningPage"
---

<objective>
Create the frontend planning session composable, extend the GRD API client, and register the planning page route.

Purpose: Establish the frontend foundation that the Planning page view (Plan 03) will consume. The composable encapsulates all PTY session management for planning commands — SSE streaming, input sending, status tracking — so the view layer stays clean. The API extensions connect to the new backend endpoints from Plan 01. The route registration enables navigation.

Output: `usePlanningSession.ts` composable, extended `grdApi`, planning route in project routes.
</objective>

<execution_context>
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-CONTEXT.md
@.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-RESEARCH.md
@frontend/src/composables/useProjectSession.ts
@frontend/src/services/api/grd.ts
@frontend/src/router/routes/projects.ts
@frontend/src/components/projects/InteractiveSetup.vue
</execution_context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePlanningSession composable</name>
  <files>frontend/src/composables/usePlanningSession.ts</files>
  <action>
    Create `frontend/src/composables/usePlanningSession.ts` following the patterns from `useProjectSession.ts` and `InteractiveSetup.vue`.

    The composable takes a `projectId: Ref<string>` parameter and returns:

    ```typescript
    interface PlanningQuestion {
      interaction_id: string;
      question_type: 'text' | 'password' | 'select' | 'multiselect';
      prompt: string;
      options?: string[];
    }

    // Return type
    {
      sessionId: Ref<string | null>;
      outputLines: Ref<string[]>;
      status: Ref<'idle' | 'running' | 'waiting_input' | 'complete' | 'error'>;
      currentQuestion: Ref<PlanningQuestion | null>;
      exitCode: Ref<number | null>;
      invokeCommand: (command: string, args?: Record<string, string>) => Promise<void>;
      sendAnswer: (answer: string) => Promise<void>;
      stopSession: () => Promise<void>;
      clearOutput: () => void;
    }
    ```

    Implementation details:

    1. **`invokeCommand(command, args?)`**:
       - Calls `grdApi.invokePlanningCommand(projectId.value, command, args)`.
       - On success, sets `sessionId.value` and `status.value = 'running'`.
       - Calls internal `connectSSE()` to start streaming.
       - On error, sets `status.value = 'error'` and pushes error message to `outputLines`.

    2. **`connectSSE()`** (internal):
       - Creates EventSource via `grdApi.streamSession(projectId.value, sessionId.value!)`.
       - Stores reference in a local `let eventSource: EventSource | null` for cleanup.
       - Attaches event listeners:
         - `'message'` (default): Parse JSON, push `data.line` or `data.output` to `outputLines`. Update `last_activity` timestamp.
         - `'output'`: Same as message — push line content to `outputLines`.
         - `'question'`: Parse JSON into `PlanningQuestion` format. Set `currentQuestion.value` and `status.value = 'waiting_input'`. The question detection follows the pattern from `InteractiveSetup.vue` — check for `data.interaction_id` and `data.prompt` fields.
         - `'complete'`: Set `status.value = 'complete'`, extract `data.exit_code`, close EventSource. Emit completion.
         - `'error'`: Set `status.value = 'error'`, close EventSource.
       - On EventSource `onerror`: If `readyState === EventSource.CLOSED`, set status to 'error'. Otherwise, let auto-reconnect handle it (EventSource reconnects by default).

    3. **`sendAnswer(answer)`**:
       - Calls `grdApi.sendInput(projectId.value, sessionId.value!, answer + '\n')`.
       - Clears `currentQuestion.value = null`.
       - Sets `status.value = 'running'`.

    4. **`stopSession()`**:
       - Calls `grdApi.stopSession(projectId.value, sessionId.value!)`.
       - Closes EventSource.
       - Sets `status.value = 'idle'`.

    5. **Cleanup**: Use `onUnmounted()` to close EventSource if still open.

    6. **`clearOutput()`**: Resets `outputLines` to empty array, `status` to 'idle', `currentQuestion` to null.

    IMPORTANT: Close EventSource on `onUnmounted()` — see RESEARCH.md Pitfall: "Forgetting to close EventSource on component unmount."

    Do NOT attempt to parse markdown or render HTML in this composable — that is the view's responsibility. The composable only manages raw text lines.
  </action>
  <verify>
    cd frontend && npx vue-tsc --noEmit
    (Level 1: Sanity — TypeScript type checking passes)
  </verify>
  <done>usePlanningSession.ts composable exists, exports the composable function, TypeScript compiles without errors. It manages EventSource lifecycle, exposes reactive state, and handles SSE events.</done>
</task>

<task type="auto">
  <name>Task 2: Extend grdApi with planning endpoints and register planning route</name>
  <files>frontend/src/services/api/grd.ts, frontend/src/services/api/types.ts, frontend/src/router/routes/projects.ts</files>
  <action>
    **Step 1: Extend grdApi** (`frontend/src/services/api/grd.ts`)

    Add the following methods to the `grdApi` object, after the existing `streamProjectChat` method:

    ```typescript
    // Planning command invocation
    invokePlanningCommand: (
      projectId: string,
      command: string,
      args?: Record<string, string>,
    ) =>
      apiFetch<{ session_id: string; status: string }>(
        `/api/projects/${projectId}/planning/invoke`,
        {
          method: 'POST',
          body: JSON.stringify({ command, args }),
        },
      ),

    // Planning initialization status
    getPlanningStatus: (projectId: string) =>
      apiFetch<{ grd_init_status: string; active_session_id: string | null }>(
        `/api/projects/${projectId}/planning/status`,
      ),
    ```

    **Step 2: Add types** (`frontend/src/services/api/types.ts`)

    Add the `PlanningStatus` interface near the existing GRD types:

    ```typescript
    export interface PlanningStatus {
      grd_init_status: 'none' | 'initializing' | 'ready' | 'failed';
      active_session_id: string | null;
    }

    export interface InvokePlanningCommandRequest {
      command: string;
      args?: Record<string, string>;
    }
    ```

    **Step 3: Register planning route** (`frontend/src/router/routes/projects.ts`)

    Add a new route entry to the `projectRoutes` array, after the `project-management` route:

    ```typescript
    {
      path: '/projects/:projectId/planning',
      name: 'project-planning',
      component: () => import('../../views/ProjectPlanningPage.vue'),
      props: true,
      meta: { title: 'Project Planning', requiresEntity: 'projectId' },
    },
    ```

    NOTE: The `ProjectPlanningPage.vue` file does not exist yet — it will be created in Plan 03. The route registration here uses a lazy import so it won't fail at build time; however, navigating to the route before Plan 03 will show a blank page. This is acceptable for Wave 1 parallel execution.

    Also make sure to re-export any new types from `frontend/src/services/api/index.ts` if the barrel file exists and re-exports types.
  </action>
  <verify>
    cd frontend && npx vue-tsc --noEmit
    (Level 1: Sanity — TypeScript type checking passes even with lazy import of not-yet-created view)

    Note: `vue-tsc` will NOT fail on lazy `import()` of a missing file during type checking because dynamic imports are resolved at runtime. But if it does fail, create a minimal placeholder `ProjectPlanningPage.vue` with `<template><div>Planning</div></template>` to unblock.
  </verify>
  <done>
    grdApi has invokePlanningCommand() and getPlanningStatus() methods. PlanningStatus type exists. Route /projects/:projectId/planning registered with lazy-loaded component. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
Level 1 (Sanity):
- `cd frontend && npx vue-tsc --noEmit` passes
- `just build` succeeds (if lazy import of missing view causes build failure, create a minimal placeholder)

Level 2 (Proxy):
- Inspect `usePlanningSession.ts` — exposes invokeCommand, sendAnswer, stopSession, clearOutput, and reactive refs
- Inspect `grdApi` — new methods match backend endpoint signatures
- Inspect project routes — planning route present with correct path and meta
</verification>

<success_criteria>
usePlanningSession composable exists with full session lifecycle management. grdApi has two new methods for planning. Planning page route registered. TypeScript type checking passes.
</success_criteria>

<output>
After completion, create `.planning/milestones/v0.1.0/phases/01-web-ui-roadmapping-feature/01-02-SUMMARY.md`
</output>
