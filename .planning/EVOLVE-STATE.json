{
  "iteration": 14,
  "timestamp": "2026-02-24T22:12:11.331Z",
  "milestone": "",
  "pick_pct": 15,
  "selected_groups": [
    {
      "id": "improve-features/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "improve-features",
      "title": "Miscellaneous (improve-features)",
      "items": [
        {
          "id": "improve-features/audit-log-ui-missing",
          "dimension": "improve-features",
          "slug": "audit-log-ui-missing",
          "title": "Audit log service exists but has no UI",
          "description": "backend/app/services/audit_log_service.py: Comprehensive audit logging is implemented, but many routes/services don't call it, and there's no frontend view to browse audit log entries. The feature is invisible to end users.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/no-retry-ui-for-failed-operations",
          "dimension": "improve-features",
          "slug": "no-retry-ui-for-failed-operations",
          "title": "No retry UI for failed executions or operations",
          "description": "frontend/src/views/WorkflowsPage.vue and execution views: When an execution fails, users must manually navigate back, reconfigure, and re-trigger. Add a 'Retry' button that replays the same parameters.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/rate-limit-approach-warning",
          "dimension": "improve-features",
          "slug": "rate-limit-approach-warning",
          "title": "No proactive warnings when approaching rate limits",
          "description": "backend/app/services/monitoring_service.py tracks rate limit usage, but the frontend has no indicator showing proximity to rate limits. Users discover limits only when executions start failing.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/sse-queue-drop-silent",
          "dimension": "improve-features",
          "slug": "sse-queue-drop-silent",
          "title": "SSE event drops are silent when queue is full",
          "description": "frontend/src/services/api/client.ts line 272: When SSE_MAX_QUEUE_SIZE (500) is exceeded, oldest events are dropped silently. This causes missed log lines in the execution view with no indication to the user that output was truncated.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/config-no-schema-validation",
          "dimension": "improve-features",
          "slug": "config-no-schema-validation",
          "title": "YAML/JSON configs loaded without schema validation",
          "description": "Multiple backend services load YAML/JSON configuration files without schema validation. Invalid config keys or wrong types silently use defaults or fail at runtime deep in execution. Add JSON Schema or Pydantic validation at load time.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 14.6,
      "effort": "medium",
      "status": "selected"
    },
    {
      "id": "stability/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "stability",
      "title": "Miscellaneous (stability)",
      "items": [
        {
          "id": "stability/swallowed-errors-execution-service",
          "dimension": "stability",
          "slug": "swallowed-errors-execution-service",
          "title": "Silent failure on repo clone error",
          "description": "backend/app/services/execution_service.py around line 598: GitHubService.clone_repo() is called without try/except. If clone fails, cloned_dirs cleanup may not execute, leaving temp dirs on disk and returning a misleading error to the caller.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/swallowed-errors-provider-usage-client",
          "dimension": "stability",
          "slug": "swallowed-errors-provider-usage-client",
          "title": "Bare except swallows credential resolution errors",
          "description": "backend/app/services/provider_usage_client.py around line 471: except (ValueError, TypeError) block swallows errors without logging. Silent failures hide misconfigurations, making it impossible to debug why token resolution failed.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/swallowed-errors-backend-detection",
          "dimension": "stability",
          "slug": "swallowed-errors-backend-detection",
          "title": "Generic except swallows subprocess errors in backend detection",
          "description": "backend/app/services/backend_detection_service.py line 81: bare except Exception catches all subprocess invocation errors without logging. Users cannot distinguish between missing binary, permission denied, or timeout.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/swallowed-errors-message-bus",
          "dimension": "stability",
          "slug": "swallowed-errors-message-bus",
          "title": "Silent failure drops messages in agent message bus",
          "description": "backend/app/services/agent_message_bus_service.py line 236: except Exception with no logging. Silent failure in message bus can silently drop messages without any trace in logs.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/in-memory-execution-state-lost-on-restart",
          "dimension": "stability",
          "slug": "in-memory-execution-state-lost-on-restart",
          "title": "In-memory execution state lost on server restart",
          "description": "ExecutionService, WorkflowExecutionService, and TeamExecutionService each maintain independent in-memory execution state dicts protected by locks. A server restart or crash silently loses all in-progress execution state. Persist active execution records to the database.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/no-api-rate-limiting",
          "dimension": "stability",
          "slug": "no-api-rate-limiting",
          "title": "No rate limiting on API endpoints",
          "description": "backend/app/routes/: None of the ~40 route handlers apply rate limiting. Any client can hammer endpoints without throttling. Add Flask-Limiter or similar middleware, especially on execution dispatch and webhook ingestion routes.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/blocking-git-clone-in-execution-thread",
          "dimension": "stability",
          "slug": "blocking-git-clone-in-execution-thread",
          "title": "Blocking git clone on execution thread",
          "description": "backend/app/services/execution_service.py around line 598: Large repository clones block the execution thread synchronously. A slow or large repo clone stalls the entire trigger execution pipeline. Offload to a thread pool or async queue.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/no-api-versioning",
          "dimension": "stability",
          "slug": "no-api-versioning",
          "title": "No API versioning strategy",
          "description": "frontend/src/services/api/client.ts and backend/app/routes/: No versioning on API routes (no /v1/ prefix or Accept-Version header). Breaking backend changes silently break already-deployed frontends with no migration path.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 13.375,
      "effort": "medium",
      "status": "selected"
    }
  ],
  "remaining_groups": [
    {
      "id": "new-features/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "new-features",
      "title": "Miscellaneous (new-features)",
      "items": [
        {
          "id": "new-features/no-dry-run-for-workflows",
          "dimension": "new-features",
          "slug": "no-dry-run-for-workflows",
          "title": "No dry-run mode for workflow validation",
          "description": "backend/app/services/workflow_execution_service.py: Workflows always execute live. A dry-run flag would validate DAG structure, resolve conditions, and show expected node execution order without triggering subprocesses or incurring API costs.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-circuit-breaker-for-backends",
          "dimension": "new-features",
          "slug": "no-circuit-breaker-for-backends",
          "title": "No circuit breaker for unavailable AI backends",
          "description": "backend/app/services/execution_service.py: If Claude, OpenCode, or Gemini becomes consistently unavailable, all dispatched executions fail individually. A circuit breaker pattern would fast-fail new requests and recover automatically when the backend is healthy.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-cost-estimation",
          "dimension": "new-features",
          "slug": "no-execution-cost-estimation",
          "title": "No pre-flight cost estimation before execution",
          "description": "backend/app/services/budget_service.py: Users cannot estimate token usage or cost before triggering an execution. A pre-flight analysis endpoint (e.g., POST /admin/executions/estimate) would help prevent budget overruns on large prompts.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-webhook-signature-validation",
          "dimension": "new-features",
          "slug": "no-webhook-signature-validation",
          "title": "No webhook payload signature validation",
          "description": "backend/app/routes/ webhook handlers: Incoming webhook payloads are processed without verifying HMAC signatures. Any party that knows the endpoint URL can trigger bot executions. Add signature verification (e.g., X-Hub-Signature-256 for GitHub webhooks).",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-diff-between-runs",
          "dimension": "new-features",
          "slug": "no-execution-diff-between-runs",
          "title": "No diff view between consecutive execution outputs",
          "description": "frontend/src/ execution views: Users cannot compare outputs between two runs of the same bot. A diff view (side-by-side or inline) would help identify regressions or evaluate prompt changes across runs.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/request-response-logging-middleware",
          "dimension": "new-features",
          "slug": "request-response-logging-middleware",
          "title": "Add centralized request/response logging middleware",
          "description": "No middleware exists to log API request latency, status codes, or errors. Add a Flask before/after_request hook to emit structured logs for all API calls, enabling latency tracking and error rate monitoring.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/circuit-breaker-external-calls",
          "dimension": "new-features",
          "slug": "circuit-breaker-external-calls",
          "title": "Add circuit breaker for external service calls",
          "description": "backend/app/services/ calls GitHub API, skills.sh, and AI providers without protection. A circuit breaker (e.g., pybreaker) would prevent cascading failures and enable graceful degradation when external services are down.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/persistent-retry-queue",
          "dimension": "new-features",
          "slug": "persistent-retry-queue",
          "title": "Replace in-memory retry scheduling with persistent queue",
          "description": "backend/app/services/execution_service.py uses threading.Timer for rate-limit retries. A persistent retry queue (APScheduler job store, Redis, or SQLite-backed) would survive server restarts and be visible in the admin UI.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/health-check-dependency-status",
          "dimension": "new-features",
          "slug": "health-check-dependency-status",
          "title": "Expose dependency health in /health endpoint",
          "description": "The /health endpoint likely returns a simple OK. Extend it to report the status of critical dependencies: DB connectivity, scheduler state, GitHub auth, and CLI tool availability. Enables better ops monitoring.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/execution-audit-trail",
          "dimension": "new-features",
          "slug": "execution-audit-trail",
          "title": "Add full execution audit trail with trigger context",
          "description": "backend/app/services/audit_log_service.py exists but execution events may not capture the full trigger context (who triggered, what payload, which prompt template version was used). Add structured execution audit records for compliance and debugging.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/workflow-execution-persistence",
          "dimension": "new-features",
          "slug": "workflow-execution-persistence",
          "title": "Persist workflow execution history to database",
          "description": "backend/app/services/workflow_execution_service.py only holds execution records in memory with a 5-minute TTL. Users cannot view historical workflow runs, debug past failures, or audit execution patterns. Persisting to the database would unlock history views and analytics.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/structured-api-error-model",
          "dimension": "new-features",
          "slug": "structured-api-error-model",
          "title": "Introduce a unified error response model",
          "description": "No single error response Pydantic model is shared across backend/app/routes/. A standardized `ErrorResponse` model with `code`, `message`, and `details` fields would improve API usability, enable consistent frontend error handling, and improve Swagger documentation.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-history-persistence",
          "dimension": "new-features",
          "slug": "no-execution-history-persistence",
          "title": "Execution state is in-memory only with 5-minute TTL",
          "description": "Per CLAUDE.md, execution status is tracked in-memory with a 5-minute TTL after completion. There is no persistent execution history in the database. Users cannot review past runs, see historical success rates, or audit what a bot did.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-trigger-dry-run-mode",
          "dimension": "new-features",
          "slug": "no-trigger-dry-run-mode",
          "title": "No dry-run mode for trigger dispatching",
          "description": "Triggers (webhook, GitHub, schedule) have no dry-run flag. Developers testing new trigger configurations must fire live executions. A dry-run mode would validate the trigger matches and show the rendered prompt without actually running the bot.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-bot-execution-rate-limit-per-trigger",
          "dimension": "new-features",
          "slug": "no-bot-execution-rate-limit-per-trigger",
          "title": "No per-trigger execution rate limiting",
          "description": "There is no mechanism to prevent a trigger from firing more than N times per hour. A misconfigured webhook or runaway GitHub event can queue unlimited executions. Per-trigger rate limiting would protect both the platform and downstream API costs.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-notification-on-execution-failure",
          "dimension": "new-features",
          "slug": "no-notification-on-execution-failure",
          "title": "No user notification when execution fails",
          "description": "When a bot execution fails or times out, there is no outbound notification (email, Slack, GitHub comment). Users must actively poll the UI to discover failures. Adding a webhook or notification hook on terminal states would close this gap.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-secrets-management",
          "dimension": "new-features",
          "slug": "no-secrets-management",
          "title": "No secrets/environment variable management for bots",
          "description": "Bots that need API keys or tokens have no secure storage mechanism. Secrets would need to be hardcoded in prompts or passed via environment variables with no encryption at rest. A per-project secrets store with masked display would enable safe credential management.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-bot-execution-queuing",
          "dimension": "new-features",
          "slug": "no-bot-execution-queuing",
          "title": "No execution queue — concurrent triggers fire immediately",
          "description": "Multiple webhook events arriving simultaneously each spawn their own subprocess immediately. There is no queue to serialize or cap concurrent executions per bot. Under load this can exhaust API rate limits or system resources.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/trigger-config-versioning",
          "dimension": "new-features",
          "slug": "trigger-config-versioning",
          "title": "No version history for trigger configuration changes",
          "description": "backend/app/db/triggers.py and backend/app/db/schema.py: trigger configs are updated in-place with no history. If a trigger is accidentally misconfigured, there is no way to restore the previous state. Add a trigger_config_history table to track changes with timestamps and author.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/workflow-conditional-branching",
          "dimension": "new-features",
          "slug": "workflow-conditional-branching",
          "title": "Workflow DAG has no conditional branch nodes",
          "description": "backend/app/models/workflow.py: all DAG nodes execute unconditionally. There is no 'if' node type that routes execution based on previous node output. Adding a condition_node type with an expression field would unlock data-driven automation flows.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/workflow-node-retry-policy",
          "dimension": "new-features",
          "slug": "workflow-node-retry-policy",
          "title": "Workflow nodes have no per-node retry policy",
          "description": "backend/app/models/workflow.py: NodeConfig has no retry_policy field. Transient failures in a single node abort the whole DAG. Add a retry_policy: {max_attempts: int, backoff_strategy: str} field so individual nodes can recover from transient errors.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/structured-logging-json-format",
          "dimension": "new-features",
          "slug": "structured-logging-json-format",
          "title": "Backend uses print() and unstructured log messages",
          "description": "backend/app/services/execution_service.py and others use print() alongside logger.* calls. Structured JSON logging (via python-json-logger or similar) would make logs parseable by log aggregation tools and simplify filtering by execution_id or bot_id.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/opentelemetry-tracing",
          "dimension": "new-features",
          "slug": "opentelemetry-tracing",
          "title": "No distributed tracing across execution pipeline",
          "description": "When an execution spans ExecutionService, MonitoringService, RotationService, and BudgetService, there is no trace context linking the spans. Add OpenTelemetry instrumentation to correlate logs and measure latency per service for each execution.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/model-discovery-persistent-cache",
          "dimension": "new-features",
          "slug": "model-discovery-persistent-cache",
          "title": "Model discovery hits external APIs on every call without a durable cache",
          "description": "backend/app/services/model_discovery_service.py attempts file-based caching but it is not reliable across restarts. A SQLite-backed cache table (model_cache with ttl_expires_at) would persist across restarts and reduce external API calls during development and production warm-up.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-circuit-breaker-for-backend-failures",
          "dimension": "new-features",
          "slug": "no-circuit-breaker-for-backend-failures",
          "title": "No circuit breaker for repeated CLI backend failures",
          "description": "backend/app/services/execution_service.py — If the claude or opencode CLI is broken, all triggers will repeatedly hammer it. Implement exponential backoff and a circuit breaker to stop wasting resources on a broken backend.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-bulk-cancel-executions",
          "dimension": "new-features",
          "slug": "no-bulk-cancel-executions",
          "title": "No bulk execution cancellation endpoint",
          "description": "backend/app/routes/executions.py — Users must cancel executions one-by-one. Add a POST /executions/cancel-bulk endpoint accepting a list of IDs or a filter (status, trigger_id) to cancel multiple at once.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-retry-for-transient-failures",
          "dimension": "new-features",
          "slug": "no-retry-for-transient-failures",
          "title": "No retry mechanism for transient execution failures",
          "description": "backend/app/services/execution_service.py — Executions fail permanently on transient errors (network timeouts, temporary CLI unavailability). Add configurable retry-with-backoff policy per trigger.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-ssh-github-url-support",
          "dimension": "new-features",
          "slug": "no-ssh-github-url-support",
          "title": "GitHub service only supports HTTPS URLs",
          "description": "backend/app/services/github_service.py — Only HTTPS repo URLs are handled. Systems using SSH key auth (common in CI environments) cannot clone repos without an API token. Add SSH URL parsing and support.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-search-filter",
          "dimension": "new-features",
          "slug": "no-execution-search-filter",
          "title": "Execution list has no search or filter capability",
          "description": "backend/app/routes/executions.py — GET /executions only supports basic pagination. Add query param filters for status, trigger_id, date range, and text search over execution output to make the log viewer usable at scale.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-api-rate-limiting",
          "dimension": "new-features",
          "slug": "no-api-rate-limiting",
          "title": "No rate limiting on REST API endpoints",
          "description": "All routes in backend/app/routes/ lack request rate limiting (only the GitHub webhook route has rate limiting). A single unauthenticated client can flood the API. Flask-Limiter or a middleware decorator would address this.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-request-id-tracing",
          "dimension": "new-features",
          "slug": "no-request-id-tracing",
          "title": "No request ID propagation for distributed tracing",
          "description": "The entire backend lacks request ID middleware. There is no way to correlate a webhook receipt, trigger match, execution start, and log lines as a single trace, making production debugging laborious.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-soft-budget-alerts",
          "dimension": "new-features",
          "slug": "no-soft-budget-alerts",
          "title": "No soft budget threshold alerts",
          "description": "backend/app/services/budget_service.py: only hard limits exist. Adding configurable soft-limit thresholds (e.g., 80% of budget) that emit warnings or notifications would let users act before executions are blocked.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-cost-projection",
          "dimension": "new-features",
          "slug": "no-execution-cost-projection",
          "title": "No real-time cost projection for running executions",
          "description": "backend/app/services/execution_service.py: token usage is only available after completion. Streaming a running token count and estimated cost during execution would give users visibility into spend before it completes.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-structured-logging",
          "dimension": "new-features",
          "slug": "no-structured-logging",
          "title": "No structured (JSON) logging for production observability",
          "description": "backend/app/: all logging uses plain text format. In production deployments, structured JSON logs (with execution_id, trigger_id, bot_id, level, timestamp as fields) are needed for log aggregation tools. Add a JSON log formatter configurable via environment variable.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-cancellation",
          "dimension": "new-features",
          "slug": "no-execution-cancellation",
          "title": "Running executions cannot be cancelled via API",
          "description": "backend/app/services/execution_service.py tracks subprocess PIDs but there is no API endpoint to cancel a running execution. Users must wait for timeouts or manually intervene at the OS level to stop runaway executions.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-health-check-for-dependencies",
          "dimension": "new-features",
          "slug": "no-health-check-for-dependencies",
          "title": "Health endpoint does not check dependency status",
          "description": "backend/app/routes/health.py returns a basic health response without verifying SQLite connectivity, scheduler status, or disk space. A detailed health check endpoint would enable load balancers and monitoring tools to detect partial outages.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-dry-run-mode",
          "dimension": "new-features",
          "slug": "no-execution-dry-run-mode",
          "title": "No dry-run mode for testing bot configurations",
          "description": "There is no way to validate a bot's prompt template or trigger configuration without actually executing it. A dry-run mode that renders the prompt with sample data and validates configuration would reduce trial-and-error during bot setup.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-pagination-on-list-endpoints",
          "dimension": "new-features",
          "slug": "no-pagination-on-list-endpoints",
          "title": "List endpoints return unbounded result sets",
          "description": "Multiple list endpoints in backend/app/routes/ (executions, teams, agents) return all records without pagination. As data grows, these endpoints will cause memory pressure and slow response times. Cursor or offset pagination is needed.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-retention-policy",
          "dimension": "new-features",
          "slug": "no-execution-retention-policy",
          "title": "Execution logs have no automated retention/cleanup",
          "description": "backend/app/services/execution_log_service.py stores execution logs indefinitely with no TTL or cleanup policy beyond the in-memory 5-minute TTL. The database will grow unbounded in production without a configurable retention policy.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-execution-audit-trail",
          "dimension": "new-features",
          "slug": "no-execution-audit-trail",
          "title": "No snapshot of trigger config at execution time",
          "description": "When a trigger's prompt template or paths are modified, old executions cannot be traced to the exact config that produced them. Should snapshot trigger config in execution_logs or a separate audit_snapshots table at dispatch time.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-conditional-retry-strategy",
          "dimension": "new-features",
          "slug": "no-conditional-retry-strategy",
          "title": "Retry only triggers on rate limits, not transient errors",
          "description": "ExecutionService retries only on rate-limit detection. Should support configurable retry strategies for transient errors (502, 503, network timeout) with pluggable backoff curves (exponential, linear, fibonacci) and max-retry caps.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/missing-execution-dry-run",
          "dimension": "new-features",
          "slug": "missing-execution-dry-run",
          "title": "No way to preview execution without running",
          "description": "Users cannot dry-run a trigger to validate prompt template rendering with real paths before committing to a full execution. Add ExecutionService.dry_run(trigger_id, paths) that returns the rendered prompt and CLI command without spawning a subprocess.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/workflow-nodes-not-parallelized",
          "dimension": "new-features",
          "slug": "workflow-nodes-not-parallelized",
          "title": "Workflow execution is purely sequential",
          "description": "WorkflowExecutionService processes nodes in topological order but does not parallelize independent branches. Two unrelated subtrees execute serially, wasting time on multi-agent workflows. Should spawn parallel threads for independent node groups.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-webhook-signature-algorithm-choice",
          "dimension": "new-features",
          "slug": "no-webhook-signature-algorithm-choice",
          "title": "Webhook signature verification locked to HMAC-SHA256",
          "description": "backend/app/routes/github_webhook.py hardcodes HMAC-SHA256 for signature verification with no way to configure alternatives. Legacy systems using HMAC-SHA1 cannot integrate. Should support algorithm selection per webhook source.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/webhook-replay",
          "dimension": "new-features",
          "slug": "webhook-replay",
          "title": "No webhook replay capability for failed deliveries",
          "description": "Failed webhook payloads are not stored anywhere. Operators must manually reproduce the original request to re-trigger. Storing the last N failed webhook payloads per trigger would allow one-click replay from the UI.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/trigger-dry-run",
          "dimension": "new-features",
          "slug": "trigger-dry-run",
          "title": "No dry-run mode for trigger execution",
          "description": "backend/app/routes/triggers.py has a preview_trigger_prompt() endpoint that renders templates but doesn't do a real dry-run. Users must consume budget to validate trigger behavior. A dry-run mode that shows resolved prompt, selected account, and estimated cost without executing would be valuable.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/execution-pause-resume",
          "dimension": "new-features",
          "slug": "execution-pause-resume",
          "title": "No pause/resume support for running executions",
          "description": "backend/app/services/execution_service.py only supports cancel (SIGTERM). There's no way to pause a running execution and resume it later. This causes data loss when executions need to be interrupted for maintenance or rate limit recovery.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/cron-expression-support",
          "dimension": "new-features",
          "slug": "cron-expression-support",
          "title": "Scheduler only supports daily/weekly/monthly, not cron expressions",
          "description": "backend/app/services/trigger_service.py and backend/app/db/triggers.py: schedule_type is limited to daily/weekly/monthly. Supporting standard cron expressions would allow precise scheduling like 'every 15 minutes during business hours' without requiring manual polling logic.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/trigger-dependency-chain",
          "dimension": "new-features",
          "slug": "trigger-dependency-chain",
          "title": "No way to chain triggers with dependency ordering",
          "description": "There's no mechanism to say 'trigger B runs after trigger A completes successfully'. Multi-stage automations require setting up a full workflow even for simple sequential chains. A lightweight trigger dependency field would cover most use cases.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/execution-cost-attribution",
          "dimension": "new-features",
          "slug": "execution-cost-attribution",
          "title": "No per-project or per-trigger cost attribution reporting",
          "description": "backend/app/services/budget_service.py tracks total token usage but there's no API to break down costs by project, trigger, or time period. Teams can't identify which automations are consuming disproportionate budget.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/rate-limit-status-api",
          "dimension": "new-features",
          "slug": "rate-limit-status-api",
          "title": "No API endpoint to inspect rate limit and retry state",
          "description": "backend/app/services/execution_service.py manages rate limiting and retry queues entirely in-memory with no observable API. Adding a GET /admin/executions/queue endpoint showing pending retries, rate limit windows, and backoff timers would enable operational visibility.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/webhook-signature-config-per-trigger",
          "dimension": "new-features",
          "slug": "webhook-signature-config-per-trigger",
          "title": "Webhook HMAC secret is global, not per-trigger",
          "description": "backend/app/routes/webhook.py: HMAC signature verification uses a single global secret. Supporting per-trigger webhook secrets would allow different senders to use different credentials, improving security isolation.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-manual-retry-for-failed-loads",
          "dimension": "new-features",
          "slug": "no-manual-retry-for-failed-loads",
          "title": "No manual retry UI for failed API loads",
          "description": "Throughout the frontend (App.vue, useConversation.ts), when data loads fail there is no retry button or mechanism. Users must refresh the entire page. Add per-section retry functionality tied to error state.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-command-whitelist-for-workflow-nodes",
          "dimension": "new-features",
          "slug": "no-command-whitelist-for-workflow-nodes",
          "title": "Workflow script nodes have no command allowlist",
          "description": "backend/app/services/workflow_execution_service.py line 759: Any shell command can be specified in a workflow node config with shell=True. Add an allowlist or sandboxing mechanism for authorized commands.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-centralized-error-loading-composable",
          "dimension": "new-features",
          "slug": "no-centralized-error-loading-composable",
          "title": "No shared error/loading state composable",
          "description": "frontend/src/composables/useAiChat.ts, useConversation.ts, useProjectSession.ts, useSketchChat.ts each define their own `error: ref<string | null>` and `isLoading: ref<boolean>` independently with no shared pattern. A `useAsyncState` composable would standardize loading/error lifecycle and reduce duplication across ~10 composables.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/no-audit-log-ui",
          "dimension": "new-features",
          "slug": "no-audit-log-ui",
          "title": "Audit log service exists but has no UI exposure",
          "description": "backend/app/services/audit_log_service.py exists (untracked new file) suggesting recent implementation of audit logging. If this service is active, there is currently no frontend view or API endpoint exposing audit log data to administrators, making the feature invisible to users.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/execution-replay",
          "dimension": "new-features",
          "slug": "execution-replay",
          "title": "No execution replay capability",
          "description": "There is no way to replay a past execution with the same inputs. Users must manually reconstruct trigger parameters. Store execution input snapshots in the database and add a 'Replay' action in the execution history view.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/webhook-retry-ui",
          "dimension": "new-features",
          "slug": "webhook-retry-ui",
          "title": "No UI to view or retry failed webhooks",
          "description": "backend/app/routes/webhook.py: Failed webhooks are processed and discarded. There's no log of received webhooks, no way to see why one failed, and no way to reprocess it. Add a webhook event log with retry capability.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/workflow-version-history",
          "dimension": "new-features",
          "slug": "workflow-version-history",
          "title": "No workflow version history or rollback",
          "description": "frontend/src/views/WorkflowsPage.vue and backend/app/db/workflows.py: Workflow edits are destructive — there's no version history and no rollback. Add a workflow_versions table and a UI to view and restore previous versions.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/bulk-entity-operations",
          "dimension": "new-features",
          "slug": "bulk-entity-operations",
          "title": "No bulk create/update/delete for entities",
          "description": "All entity management (agents, bots, plugins, skills) requires one operation at a time. There are no bulk endpoints or multi-select UI actions. Large teams managing many agents must operate serially.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "new-features/migration-preflight-checks",
          "dimension": "new-features",
          "slug": "migration-preflight-checks",
          "title": "No pre-flight schema consistency check before migrations",
          "description": "backend/app/db/migrations.py: Migrations run without verifying the current schema is in the expected state. If a previous migration partially failed, the next one may produce corrupt state. Add a schema fingerprint check before each migration.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 12.819672131147541,
      "effort": "large",
      "status": "pending"
    },
    {
      "id": "consistency/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "consistency",
      "title": "Miscellaneous (consistency)",
      "items": [
        {
          "id": "consistency/print-vs-logger-inconsistency",
          "dimension": "consistency",
          "slug": "print-vs-logger-inconsistency",
          "title": "Mixed print() and logger usage across backend",
          "description": "backend/app/services/execution_service.py (51+ print() calls at lines 83, 85, 100, 166, 174, 179, 208, 259, 260, 338, 350, 390, 403, 410, 438, 465, 497, 500, 541, 604, 612, etc.): 62 files use the logging module while 51 print() calls exist in critical service paths. Prevents log-level control and centralized log management.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-error-response-envelope",
          "dimension": "consistency",
          "slug": "inconsistent-error-response-envelope",
          "title": "Inconsistent error response structure across routes",
          "description": "backend/app/routes/teams.py and backend/app/routes/super_agents.py: Some endpoints return `{\"error\": \"...\"}`, others `{\"message\": \"...\"}` for success and failure. No consistent API response envelope, making frontend error handling fragile.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-logging-levels",
          "dimension": "consistency",
          "slug": "inconsistent-logging-levels",
          "title": "Inconsistent logging levels across services",
          "description": "Some services use logger.info(), others logger.debug(), and others print(). There is no documented convention for when to use each level, making log filtering unreliable.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-error-return-types",
          "dimension": "consistency",
          "slug": "inconsistent-error-return-types",
          "title": "Inconsistent error signaling in service layer",
          "description": "execution_service.py and orchestration_service.py return Optional[str] with different semantics (None can mean budget failure, rate-limit retry, or no match). Should use explicit result types or exceptions.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-return-type-hints",
          "dimension": "consistency",
          "slug": "inconsistent-return-type-hints",
          "title": "Inconsistent return type annotations in services",
          "description": "backend/app/services/skills_sh_service.py has some methods with `Tuple[dict, int]` hints, others with none. backend/app/services/github_service.py lines 88, 100, 107, 122, 135, 150 are missing return hints. Makes IDE assistance unreliable.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/deprecated-group-id-field",
          "dimension": "consistency",
          "slug": "deprecated-group-id-field",
          "title": "Deprecated group_id field retained in triggers schema",
          "description": "backend/app/db/triggers.py lines 35 and 48 retain a deprecated `group_id` field. No migration path or removal timeline documented. Confuses new contributors.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/len-check-antipattern",
          "dimension": "consistency",
          "slug": "len-check-antipattern",
          "title": "len(x) == 0 checks instead of idiomatic `not x`",
          "description": "backend/app/services/team_service.py:35,43,52,103,106,117 and backend/app/services/model_discovery_service.py:127 use `len(x) > 0` / `len(x) == 0` instead of Python's idiomatic `if x:` / `if not x:`. Minor but widespread inconsistency.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/route-logging-absent",
          "dimension": "consistency",
          "slug": "route-logging-absent",
          "title": "Routes almost never log incoming requests or errors",
          "description": "Across ~40 route files in backend/app/routes/, only ~12 logger calls exist across hundreds of route handlers. API request tracing, authorization failures, and unexpected inputs go unlogged, making production debugging rely entirely on exception stack traces.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/mixed-id-prefix-conventions",
          "dimension": "consistency",
          "slug": "mixed-id-prefix-conventions",
          "title": "ID prefix convention not enforced uniformly",
          "description": "CLAUDE.md documents entity ID prefixes (bot-, agent-, conv-, team-, prod-, proj-, plug-) but there is no central factory or validator enforcing this. New entities created without reviewing CLAUDE.md may use wrong or missing prefixes, causing inconsistent data.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/placeholder-replacement-not-centralized",
          "dimension": "consistency",
          "slug": "placeholder-replacement-not-centralized",
          "title": "Template placeholder replacement has no registry",
          "description": "In backend/app/services/execution_service.py, each trigger type manually calls .replace() for each known placeholder. Adding a new placeholder requires updating each trigger branch individually. A dict-based format() or Jinja2 approach would centralize this.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/exception-handling-inconsistent",
          "dimension": "consistency",
          "slug": "exception-handling-inconsistent",
          "title": "Exception handling severity and context are inconsistent",
          "description": "In backend/app/services/execution_service.py, some exceptions are caught with full context (execution_id, trigger name), others with minimal context (line 259 logs just the exception), and others are silently passed. No consistent pattern across the service.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/thread-daemon-flag-inconsistent",
          "dimension": "consistency",
          "slug": "thread-daemon-flag-inconsistent",
          "title": "Thread daemon flag set inconsistently",
          "description": "In backend/app/services/execution_service.py, some spawned threads are explicitly set as daemon threads (around lines 416-425) while others have no explicit daemon setting (around lines 698-703, 854-858). Without documentation or a consistent policy, lifecycle behavior is unpredictable at shutdown.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/backend-type-validation-silent-correction",
          "dimension": "consistency",
          "slug": "backend-type-validation-silent-correction",
          "title": "Invalid backend_type silently corrected without persisting fix",
          "description": "In backend/app/db/triggers.py, add_trigger() validates backend_type and falls back to 'claude' for unknown values with only a log warning. The invalid value is still stored in the database — the correction is in-memory only, creating a persistent inconsistency.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/api-error-response-format-varies",
          "dimension": "consistency",
          "slug": "api-error-response-format-varies",
          "title": "API error response format varies across routes",
          "description": "In backend/app/routes/, some endpoints return {\"error\": \"message\"} (e.g., workflows.py), others return {\"message\": \"...\"}, and others raise HTTP exceptions directly. Clients cannot reliably parse error responses.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/db-function-prefix-inconsistency",
          "dimension": "consistency",
          "slug": "db-function-prefix-inconsistency",
          "title": "DB functions inconsistently use add_ vs create_ prefix",
          "description": "backend/app/db/: monitoring.py uses insert_rate_limit_snapshot(), agents.py uses add_agent(), other modules use create_*. Pick one prefix (create_ is most idiomatic) and rename all functions consistently across the db package.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/service-classmethod-vs-instance-inconsistency",
          "dimension": "consistency",
          "slug": "service-classmethod-vs-instance-inconsistency",
          "title": "Services inconsistently use @classmethod vs instance methods",
          "description": "ExecutionLogService, MonitoringService, and RotationService use @classmethod for all methods while other services use instance methods. There's no documented rationale. Decide on one pattern and apply it consistently, or document why each service uses its pattern.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/typescript-message-type-naming",
          "dimension": "consistency",
          "slug": "typescript-message-type-naming",
          "title": "Frontend uses ConversationMessage, ChatMessage, and Message interchangeably",
          "description": "frontend/src/services/api/types.ts and composables: ConversationMessage, ChatMessage, and Message refer to overlapping concepts. Consolidate into one canonical type (ConversationMessage) and update all consumers to use it.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/team-canvas-any-type",
          "dimension": "consistency",
          "slug": "team-canvas-any-type",
          "title": "useTeamCanvas uses any[] for members parameter",
          "description": "frontend/src/composables/useTeamCanvas.ts line ~38: members parameter typed as any[]. Should be typed as Agent[] | SuperAgent[] to catch type errors at compile time. This also documents intent to future readers.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/config-naming-magic-strings",
          "dimension": "consistency",
          "slug": "config-naming-magic-strings",
          "title": "Config type discriminators are magic strings scattered across codebase",
          "description": "backend/app/: monitoring_config, trigger_config_snapshot, topology_config, config_json all refer to different config shapes via string keys. Introduce typed constants or an enum (CONFIG_TYPE_MONITORING, CONFIG_TYPE_TOPOLOGY) to avoid typos and enable IDE autocomplete.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/mixed-print-and-logger",
          "dimension": "consistency",
          "slug": "mixed-print-and-logger",
          "title": "Same files mix print() and logger calls",
          "description": "backend/app/services/execution_service.py — logger.info/warning used on lines 72-76 but print() used on lines 323,389,397,412+. Inconsistency makes log aggregation unreliable. Standardize on logger throughout.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-exception-handling-github",
          "dimension": "consistency",
          "slug": "inconsistent-exception-handling-github",
          "title": "Inconsistent exception tuples across GitHub service methods",
          "description": "backend/app/services/github_service.py — validate_repo_url() catches (TimeoutExpired, FileNotFoundError, Exception) but clone_repo() catches (TimeoutExpired, RuntimeError, Exception). No consistent exception handling strategy.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/random-vs-secrets-id-generation",
          "dimension": "consistency",
          "slug": "random-vs-secrets-id-generation",
          "title": "random.choices() used for ID generation instead of secrets",
          "description": "backend/app/routes/super_agents.py:315-318 — _generate_message_id() uses random.choices() while other ID generation in the codebase uses secrets.choice(). Use secrets everywhere for cryptographic safety.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/async-operation-pattern-mismatch",
          "dimension": "consistency",
          "slug": "async-operation-pattern-mismatch",
          "title": "Inconsistent async operation patterns across routes",
          "description": "backend/app/routes/teams.py:93-144 uses in-memory job store with locks; backend/app/routes/super_agents.py:352-541 uses threading.Thread directly. Unify to one pattern to reduce maintenance surface.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/path-model-pattern-inconsistency",
          "dimension": "consistency",
          "slug": "path-model-pattern-inconsistency",
          "title": "Path parameter extraction inconsistent across routes",
          "description": "backend/app/routes/executions.py:24-48 defines path models, but some routes do inline path extraction. Standardize on APIBlueprint path models throughout all route files.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/dual-total-fields-in-response",
          "dimension": "consistency",
          "slug": "dual-total-fields-in-response",
          "title": "List responses return both 'total' and 'total_count'",
          "description": "backend/app/routes/executions.py lines 43-48: paginated responses include both `total` and `total_count` with the same value. Other routes use only one field. Standardize to a single pagination envelope across all list endpoints.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-error-response-schema",
          "dimension": "consistency",
          "slug": "inconsistent-error-response-schema",
          "title": "Inconsistent error response schemas across routes",
          "description": "Multiple route files use different error shapes: `{\"error\": \"...\"}`, `{\"message\": \"...\"}`, or bare strings. Frontend must handle multiple patterns. Define a shared ErrorResponse Pydantic model and use it everywhere.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/frontend-error-handling-inconsistency",
          "dimension": "consistency",
          "slug": "frontend-error-handling-inconsistency",
          "title": "Mix of toast errors and silent console.warn in frontend",
          "description": "frontend/src/composables/useAiChat.ts lines 48-110 and frontend/src/App.vue lines 60-112: some errors show toasts, others silently log to console.warn. Users see blank UI with no feedback when background loads fail.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/mixed-log-levels-in-exception-handlers",
          "dimension": "consistency",
          "slug": "mixed-log-levels-in-exception-handlers",
          "title": "Inconsistent log levels in exception handlers",
          "description": "backend/app/services/cliproxy_manager.py lines 57, 117, 143, 192, 234, 341+: some catch blocks use logger.debug(), others use logger.warning() for the same type of failure. Establish a convention: use logger.exception() for unexpected errors, logger.warning() for expected degraded paths.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/f-string-lazy-logging-inconsistency",
          "dimension": "consistency",
          "slug": "f-string-lazy-logging-inconsistency",
          "title": "f-string interpolation used in logger calls instead of lazy %s",
          "description": "backend/app/services/monitoring_service.py lines 51, 70 and throughout multiple services: logger.warning(f\"...\") eagerly interpolates strings even when the log level is suppressed. Use logger.warning(\"%s\", value) or structured logging.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/hardcoded-magic-numbers",
          "dimension": "consistency",
          "slug": "hardcoded-magic-numbers",
          "title": "Magic numbers scattered across services",
          "description": "backend/app/services/execution_service.py line 88 (max_retries=5), backend/app/services/workflow_execution_service.py line 36 (timeout=1800), backend/app/services/workflow_trigger_service.py line 24 (debounce=1.0): constants with no names or configuration, duplicated across files.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/global-in-memory-job-store-teams-route",
          "dimension": "consistency",
          "slug": "global-in-memory-job-store-teams-route",
          "title": "In-memory job dict in teams route is not thread-safe",
          "description": "backend/app/routes/teams.py lines 54-57: _jobs dict used for tracking async topology generation is module-level global state without a lock. Concurrent POST requests can corrupt this dict.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/workflow-route-validation-deferred-to-execution",
          "dimension": "consistency",
          "slug": "workflow-route-validation-deferred-to-execution",
          "title": "Workflow DAG validation deferred to execution time",
          "description": "backend/app/routes/workflows.py (385 lines): workflow graph structure (node types, edge validity, cycle detection) is only validated when execution starts, not at creation/update time. Invalid workflows should be rejected at the API boundary.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/rrule-nonthrowing-exception-variable",
          "dimension": "consistency",
          "slug": "rrule-nonthrowing-exception-variable",
          "title": "Exception variable named _dir_err signals intentional suppression",
          "description": "backend/app/services/execution_service.py line 48: except Exception as _dir_err — naming the variable with a leading underscore is idiomatic for \"intentionally unused\" but this obscures that the exception is being discarded. Should either handle it or document why it is safe to ignore.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-error-response-format",
          "dimension": "consistency",
          "slug": "inconsistent-error-response-format",
          "title": "API error responses have inconsistent structure",
          "description": "Across backend/app/routes/, some endpoints return `{\"error\": str}`, others return different shapes. There is no centralized error response handler or shared error schema. Frontend clients cannot reliably parse error responses.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-log-formatting",
          "dimension": "consistency",
          "slug": "inconsistent-log-formatting",
          "title": "Log messages mix f-strings and % formatting",
          "description": "backend/app/services/monitoring_service.py mixes `logger.warning(f\"...\")` and `logger.warning(\"...\", %s)` in adjacent lines (e.g., lines 50-82). Inconsistent formatting complicates log aggregation and parsing.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/any-types-in-frontend",
          "dimension": "consistency",
          "slug": "any-types-in-frontend",
          "title": "TypeScript `any` types undermine type safety",
          "description": "frontend/src/services/api/types.ts:528 uses `config: Record<string, any>` and frontend/src/services/api/triggers.ts:178 has untyped return values. Multiple `any` uses across the frontend eliminate the benefits of TypeScript type checking.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/env-var-usage-inconsistent",
          "dimension": "consistency",
          "slug": "env-var-usage-inconsistent",
          "title": "Environment variable access patterns are inconsistent",
          "description": "Some backend services use `os.environ.get('KEY', default)`, others use hardcoded fallback values inline. Missing environment variables fail silently at use-time rather than loudly at startup, making misconfigured deployments hard to diagnose.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/magic-numbers-scattered",
          "dimension": "consistency",
          "slug": "magic-numbers-scattered",
          "title": "Magic numbers scattered across services",
          "description": "Configuration constants like MAX_RETRY_ATTEMPTS, retry delays, and alert thresholds are hardcoded in backend/app/services/execution_service.py:89, backend/app/services/rotation_service.py:35-38, and others instead of being centralized in a config module.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-error-return-patterns",
          "dimension": "consistency",
          "slug": "inconsistent-error-return-patterns",
          "title": "Services use mixed error return patterns",
          "description": "Some routes return (dict, HTTPStatus) tuples, others raise exceptions. ExecutionService.run_trigger() returns Optional[str] where None means either failure or no-op. Should use a discriminated result type (ExecutionResult with status enum).",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/database-function-naming",
          "dimension": "consistency",
          "slug": "database-function-naming",
          "title": "Database CRUD functions have inconsistent return types",
          "description": "CRUD functions across backend/app/db/ mix return types: some return Optional[int] (lastrowid), others Optional[str] (id), others bool. Should standardize: create returns str id, update returns bool, delete returns bool.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/logging-level-inconsistency",
          "dimension": "consistency",
          "slug": "logging-level-inconsistency",
          "title": "Inconsistent logging levels across services",
          "description": "backend/app/services/execution_service.py logs retry scheduling at INFO but failed retries also at ERROR inconsistently. Establish conventions: INFO for state changes, DEBUG for flow details, WARNING for recoverable issues, ERROR for failures.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/api-response-shape-inconsistency",
          "dimension": "consistency",
          "slug": "api-response-shape-inconsistency",
          "title": "API responses have inconsistent envelope structure",
          "description": "Some endpoints return {\"items\": [...], \"total\": N}, others return {\"data\": [...]}, others return the object directly. Should define a standard response envelope: {\"success\": bool, \"data\": T, \"error\": Optional[ErrorDetail]}.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/frontend-error-handling-pattern",
          "dimension": "consistency",
          "slug": "frontend-error-handling-pattern",
          "title": "Frontend composables handle errors inconsistently",
          "description": "frontend/src/composables/useAiChat.ts catches errors and sets error.value, but other composables use different patterns (throw, console.error, silent ignore). Should establish a shared useErrorHandler composable.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-exception-handling",
          "dimension": "consistency",
          "slug": "inconsistent-exception-handling",
          "title": "Three different exception handling patterns across routes",
          "description": "backend/app/routes/webhook.py line 70 uses bare except Exception logging as exception; github_webhook.py line 177 uses same pattern but logs as warning; plugins.py uses redundant chained except ValueError then except Exception. No consistent pattern exists.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/migrations-use-print-not-logger",
          "dimension": "consistency",
          "slug": "migrations-use-print-not-logger",
          "title": "Migration events use print() instead of logger",
          "description": "backend/app/db/migrations.py lines 134, 153, 488, 499 use print() for migration status output instead of structured logging. These messages bypass the logging pipeline and won't appear in production log aggregators.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/hardcoded-timeout-values",
          "dimension": "consistency",
          "slug": "hardcoded-timeout-values",
          "title": "Timeout values hardcoded across multiple files",
          "description": "backend/app/services/process_manager.py line 74 hardcodes SIGTERM grace period to 10s; backend/app/services/github_service.py lines 18-19 hardcodes clone timeout 300s and op timeout 120s; frontend/src/services/api/client.ts lines 12-16 hardcodes API timeout 30s. None are configurable.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-input-validation-layer",
          "dimension": "consistency",
          "slug": "inconsistent-input-validation-layer",
          "title": "Input validation split between routes and services",
          "description": "Some routes validate inline with data.get() checks while services expect pre-validated dicts. There's no shared validation layer, causing duplicated and inconsistent checks. Example: trigger_service.py lines 75-79 validates fields that routes should have already validated.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-error-handling-composables",
          "dimension": "consistency",
          "slug": "inconsistent-error-handling-composables",
          "title": "Error handling patterns vary widely across composables",
          "description": "frontend/src/composables/useDataPage.ts has a proper isLoading/loadError pattern. useConversation.ts and useAiChat.ts use silent catches and console.warn. Standardize on a shared async error handling utility.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-query-param-validation",
          "dimension": "consistency",
          "slug": "inconsistent-query-param-validation",
          "title": "Some routes validate query params, others do not",
          "description": "backend/app/routes/budgets.py (lines 188-232) and backend/app/routes/audit.py (lines 27-39) extract query parameters (entity_type, start_date, project_path) without validation, while path parameters use Pydantic models consistently. Apply Pydantic query models uniformly.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/conversation-api-type-in-wrong-file",
          "dimension": "consistency",
          "slug": "conversation-api-type-in-wrong-file",
          "title": "ConversationApi interface defined in composable, not types file",
          "description": "frontend/src/composables/useConversation.ts lines 11-20 defines the ConversationApi interface. It should live in frontend/src/services/api/types.ts for discoverability and reuse.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/duplicate-sse-setup-across-composables",
          "dimension": "consistency",
          "slug": "duplicate-sse-setup-across-composables",
          "title": "SSE connection setup is duplicated in useConversation and useAiChat",
          "description": "frontend/src/composables/useConversation.ts (lines 99-179) and useAiChat.ts (lines 202-260) independently implement EventSource setup, event queueing, and deduplication with slight differences. Extract to a shared useEventSource.ts composable.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-route-error-handling",
          "dimension": "consistency",
          "slug": "inconsistent-route-error-handling",
          "title": "Inconsistent error response patterns across route handlers",
          "description": "backend/app/routes/: some route handlers use `try/except Exception: return error, 500`, some add `logger.error`, and some have no error handling at all. A shared error handling decorator or context manager would enforce consistent HTTP error responses and logging across all endpoints.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-logging-conventions",
          "dimension": "consistency",
          "slug": "inconsistent-logging-conventions",
          "title": "Inconsistent logging levels and exc_info usage across services",
          "description": "backend/app/services/: some files use `logger.warning` for recoverable errors while others use `logger.error` for the same severity. Some exception logs include `exc_info=True` for stack traces, others omit it. Standardize: use warning for expected/recoverable, error+exc_info for unexpected failures.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/router-guards-duplicated-pattern",
          "dimension": "consistency",
          "slug": "router-guards-duplicated-pattern",
          "title": "12 duplicated entity validator functions in router guards",
          "description": "frontend/src/router/guards.ts lines 24-58: All 12 entity validators use the exact same pattern but with different API calls. Changing validation logic requires editing 12 places. Extract to a createEntityGuard(apiFn) factory function.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/inconsistent-composable-error-handling",
          "dimension": "consistency",
          "slug": "inconsistent-composable-error-handling",
          "title": "Inconsistent error handling patterns across 25+ composables",
          "description": "frontend/src/composables/: Some composables log errors (useAiChat.ts), some emit toasts, some silently swallow them (useProjectSession.ts). No standardized error boundary or consistent pattern for surfacing API failures to users.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/business-logic-in-route-handlers",
          "dimension": "consistency",
          "slug": "business-logic-in-route-handlers",
          "title": "Business logic mixed into route handlers",
          "description": "backend/app/routes/teams.py line 166+ and other route files: Validation logic and data transformation is inline in route handlers rather than delegated to the service layer. Makes logic harder to test in isolation and creates inconsistency across routes.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "consistency/conversation-service-fragmentation",
          "dimension": "consistency",
          "slug": "conversation-service-fragmentation",
          "title": "5 conversation services with subtle pattern divergence",
          "description": "backend/app/services/: agent_conversation_service.py, base_conversation_service.py, and related files follow similar patterns with subtle differences in state management and error paths. Consolidate shared logic and document where intentional differences exist.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 11.473684210526315,
      "effort": "large",
      "status": "pending"
    },
    {
      "id": "usability/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "usability",
      "title": "Miscellaneous (usability)",
      "items": [
        {
          "id": "usability/subprocess-command-no-input-validation",
          "dimension": "usability",
          "slug": "subprocess-command-no-input-validation",
          "title": "Subprocess command built without input validation",
          "description": "backend/app/services/execution_service.py lines 104-138 (build_command): Paths and prompt strings from user input are directly interpolated into subprocess command lists with no length, character set, or path-traversal validation.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/schema-py-lacks-inline-docs",
          "dimension": "usability",
          "slug": "schema-py-lacks-inline-docs",
          "title": "schema.py lacks documentation on table relationships",
          "description": "backend/app/db/schema.py (1262 lines): Table definitions have no inline comments explaining foreign key relationships, nullable constraints rationale, or index purposes. Onboarding new developers requires reverse-engineering the data model.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/api-error-messages-not-user-friendly",
          "dimension": "usability",
          "slug": "api-error-messages-not-user-friendly",
          "title": "Raw exception messages leak to API responses",
          "description": "backend/app/routes/ multiple files: Several exception handlers return raw Python exception strings (e.g., `str(e)`) directly in API responses. These messages are developer-facing and confusing to end users; they also leak internal implementation details.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/poor-error-response-structure",
          "dimension": "usability",
          "slug": "poor-error-response-structure",
          "title": "All API errors return unstructured dicts",
          "description": "Routes return `{\"error\": \"some string\"}` without error codes, details, or suggested actions. Clients cannot programmatically distinguish between not-found, validation failure, and internal error.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/sse-stream-no-error-handling",
          "dimension": "usability",
          "slug": "sse-stream-no-error-handling",
          "title": "SSE execution stream breaks with 500 on failure",
          "description": "backend/app/routes/executions.py lines 86-88 wraps a generator for SSE streaming without error handling. On failure the stream closes abruptly with a 500 instead of sending a structured error event.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/cli-error-not-surfaced",
          "dimension": "usability",
          "slug": "cli-error-not-surfaced",
          "title": "CLI subprocess errors not surfaced to users clearly",
          "description": "backend/app/services/execution_service.py logs subprocess failures but does not distinguish between tool errors, permission errors, and auth failures in the execution result visible to users.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/monitoring-auto-enable-surprising",
          "dimension": "usability",
          "slug": "monitoring-auto-enable-surprising",
          "title": "Monitoring silently auto-enables when accounts exist",
          "description": "backend/app/services/monitoring_service.py lines 54-70 auto-enables monitoring when accounts are detected. This is surprising behavior with no notification to the user that monitoring was started.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-api-docstrings",
          "dimension": "usability",
          "slug": "missing-api-docstrings",
          "title": "Service methods missing docstrings for non-obvious behavior",
          "description": "backend/app/services/execution_service.py `_stream_pipe()` (line 222) has a rate-limit detection side effect not mentioned in any comment. backend/app/services/process_manager.py `register()` (line 32) doesn't explain lifecycle semantics.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-sse-endpoint-docs",
          "dimension": "usability",
          "slug": "missing-sse-endpoint-docs",
          "title": "SSE streaming endpoint lacks documentation",
          "description": "backend/app/routes/executions.py:77-85 stream endpoint has a minimal docstring with no documentation of SSE event types, reconnection behavior, timeout handling, or example client code. Frontend developers must read implementation to understand the contract.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-workflow-schema-docs",
          "dimension": "usability",
          "slug": "missing-workflow-schema-docs",
          "title": "Workflow create endpoint missing field documentation",
          "description": "backend/app/routes/workflows.py:60-80 — the create workflow handler doesn't document which fields are required vs optional or their valid values/constraints. Callers must inspect the Pydantic model to understand the API.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/hardcoded-report-directory",
          "dimension": "usability",
          "slug": "hardcoded-report-directory",
          "title": "Report directory path hardcoded in execution service",
          "description": "backend/app/services/execution_service.py:31 hardcodes `TRIGGER_LOG_DIR = os.path.join(PROJECT_ROOT, '.claude/skills/weekly-security-audit/reports')`. This path cannot be changed without modifying source code, preventing flexible deployment configurations.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/hardcoded-cliproxy-path",
          "dimension": "usability",
          "slug": "hardcoded-cliproxy-path",
          "title": "CLI proxy API path hardcoded",
          "description": "backend/app/services/cliproxy_manager.py:34-35 hardcodes `~/.cli-proxy-api/` as the proxy location. Different environments or multi-user setups cannot configure an alternate path without code changes.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/github-pr-creation-error-unclear",
          "dimension": "usability",
          "slug": "github-pr-creation-error-unclear",
          "title": "GitHub PR creation failure gives no actionable error",
          "description": "In backend/app/services/github_service.py around lines 200-205, when PR creation fails only raw stderr is printed. Users cannot distinguish between auth failures, branch-already-exists, or rate limiting from the output.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/execution-timeout-not-documented",
          "dimension": "usability",
          "slug": "execution-timeout-not-documented",
          "title": "10-minute execution timeout is hardcoded with no documentation",
          "description": "In backend/app/services/execution_service.py, the execution timeout (10 minutes) appears to be hardcoded with no reference in CLAUDE.md, API docs, or UI. Users running long tasks have no way to know their execution will be killed.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/thread-safety-docs-scattered-in-comments",
          "dimension": "usability",
          "slug": "thread-safety-docs-scattered-in-comments",
          "title": "Thread safety requirements only in inline comments, not docstrings",
          "description": "In backend/app/services/execution_log_service.py (lines 43-50) and execution_service.py (lines 38-46), thread safety requirements are described in inline comments rather than class/method docstrings. Callers have no IDE-visible documentation about locking requirements.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-openapi-descriptions-on-routes",
          "dimension": "usability",
          "slug": "missing-openapi-descriptions-on-routes",
          "title": "Many route handlers lack OpenAPI summary/description fields",
          "description": "Multiple route files in backend/app/routes/ define endpoints via APIBlueprint but omit the summary= and description= parameters on route decorators. The generated Swagger UI at /docs shows blank descriptions for many endpoints, reducing its usefulness.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/shared-state-lifecycle-undocumented",
          "dimension": "usability",
          "slug": "shared-state-lifecycle-undocumented",
          "title": "In-memory shared state dicts lack documented lifecycle semantics",
          "description": "backend/app/services/execution_log_service.py lines 48–56: _log_buffers, _subscribers, _start_times share a lock but their cleanup policy (TTL, who removes stale entries) is not documented. Add docstrings explaining when entries are added, when they expire, and who is responsible for cleanup.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/skill-config-delimiter-undocumented",
          "dimension": "usability",
          "slug": "skill-config-delimiter-undocumented",
          "title": "SKILL_CONFIG delimiter format is undocumented magic string",
          "description": "backend/app/services/skill_conversation_service.py lines 42–51: '---SKILL_CONFIG---' / '---END_CONFIG---' delimiters are hardcoded strings with no schema or specification document. If format changes, consumer code breaks silently. Define a CONFIG_DELIMITER constant and add a comment pointing to the spec or explaining the format.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/state-delta-protocol-undefined",
          "dimension": "usability",
          "slug": "state-delta-protocol-undefined",
          "title": "state_delta SSE protocol is referenced but never specified",
          "description": "frontend/src/composables/useAiChat.ts lines 8–16: references 'state_delta protocol (37-02)' with no link to spec or schema. If backend changes the protocol, frontend silently breaks. Document the protocol structure inline or link to a schema file.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/account-config-path-not-validated",
          "dimension": "usability",
          "slug": "account-config-path-not-validated",
          "title": "Account creation accepts unreadable config_path without validation",
          "description": "backend/app/services/backend_service.py lines 94–127: create_account() inserts config_path and api_key_env into the DB without checking if the path exists or the env var is set. Fail fast with a clear message rather than allowing the bot to fail at runtime.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/was-rate-limited-undefined",
          "dimension": "usability",
          "slug": "was-rate-limited-undefined",
          "title": "was_rate_limited() called but never defined",
          "description": "backend/app/services/orchestration_service.py:198-200 — Code calls was_rate_limited(execution_id) which is not imported or defined anywhere. This will raise NameError at runtime under rate-limit conditions.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/backend-fallback-no-docs",
          "dimension": "usability",
          "slug": "backend-fallback-no-docs",
          "title": "Backend resolution fallback logic is undocumented",
          "description": "backend/app/routes/super_agents.py:383-386 — The auto→None→lookup fallback hierarchy has no docstring or comment. API consumers can't predict which backend will be used when 'auto' is passed.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/unused-raw-payload-parameter",
          "dimension": "usability",
          "slug": "unused-raw-payload-parameter",
          "title": "Captured raw_payload parameter never used in webhook handler",
          "description": "backend/app/routes/webhook.py:34-60 — raw_payload is captured on line 38 but never referenced. Confuses API consumers about what the endpoint actually processes. Remove or use it.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/schema-no-documentation",
          "dimension": "usability",
          "slug": "schema-no-documentation",
          "title": "Database schema has no documentation on constraints or relationships",
          "description": "backend/app/db/schema.py — Large schema file has zero inline documentation about foreign key constraints, cascade behavior, or migration strategy. New contributors can't understand data relationships without reverse-engineering.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/executions-total-field-ambiguous",
          "dimension": "usability",
          "slug": "executions-total-field-ambiguous",
          "title": "Execution list response total field is ambiguous",
          "description": "backend/app/routes/executions.py:46 — total in the response equals len(executions) (page slice size, not database total). No docs clarifying this. Clients building pagination UIs will miscalculate page counts.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/sse-replay-limit-unhelpful-message",
          "dimension": "usability",
          "slug": "sse-replay-limit-unhelpful-message",
          "title": "SSE replay limit exceeded message doesn't help user",
          "description": "backend/app/services/execution_log_service.py:195 — Message says 'connect sooner' but doesn't mention the limit value, that it's configurable, or how to increase it. Should reference the relevant env var.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-loading-state-sidebar",
          "dimension": "usability",
          "slug": "no-loading-state-sidebar",
          "title": "No loading state during sidebar data loading",
          "description": "frontend/src/App.vue lines 60-112: 6 independent API calls fire in parallel on mount with `.catch(err => console.warn(...))`. No loading indicator is shown, no user feedback if all fail — sidebar silently renders empty.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-loading-states-async-views",
          "dimension": "usability",
          "slug": "missing-loading-states-async-views",
          "title": "Views render blank while async data loads",
          "description": "frontend/src/views/ (multiple files): many views fire async operations on mount without showing loading spinners or skeleton screens, causing users to see blank pages and assume the app is broken.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/github-webhook-generic-500",
          "dimension": "usability",
          "slug": "github-webhook-generic-500",
          "title": "GitHub webhook returns generic 500 with no actionable detail",
          "description": "backend/app/routes/github_webhook.py lines 169-171: bare `except Exception` returns a generic 500 with no distinction between invalid JSON, database errors, rate limit errors, or GitHub API errors, making webhook debugging hard.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/skills-api-failure-no-error-distinction",
          "dimension": "usability",
          "slug": "skills-api-failure-no-error-distinction",
          "title": "Skills API failure returns empty list with no error detail",
          "description": "backend/app/services/skills_sh_service.py lines 183-185: returns an empty list on any API failure without distinguishing between timeout, auth failure, and server errors, leaving users with no actionable feedback.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/workflow-node-input-format-undocumented",
          "dimension": "usability",
          "slug": "workflow-node-input-format-undocumented",
          "title": "Workflow input_json format not documented",
          "description": "backend/app/services/workflow_execution_service.py line 85+: execute_workflow() accepts input_json but the expected schema, supported node types, and edge semantics are not described in docstrings or API docs. Users cannot build workflows without reading source code.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/prompt-template-placeholders-undocumented",
          "dimension": "usability",
          "slug": "prompt-template-placeholders-undocumented",
          "title": "Prompt template placeholder syntax is undocumented",
          "description": "backend/app/services/execution_service.py lines 500-512: placeholders like {paths}, {message}, {pr_url} are substituted into bot prompts but there is no schema, validation, or documentation of available placeholders exposed to users.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-pagination-on-list-endpoints",
          "dimension": "usability",
          "slug": "missing-pagination-on-list-endpoints",
          "title": "List endpoints have no pagination",
          "description": "backend/app/routes/: endpoints like GET /api/executions, GET /api/teams, GET /api/workflows return unbounded result sets. No limit/offset or cursor pagination parameters are accepted, risking slow responses as data grows.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/rate-limit-backoff-undocumented",
          "dimension": "usability",
          "slug": "rate-limit-backoff-undocumented",
          "title": "Rate-limit retry backoff formula undocumented",
          "description": "backend/app/services/execution_service.py lines 249-295: the retry scheduling logic uses timer-based backoff but the formula, maximum delay, and jitter (if any) are not documented. Users see executions stuck in retry state with no ETA.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/file-watcher-pattern-syntax-undocumented",
          "dimension": "usability",
          "slug": "file-watcher-pattern-syntax-undocumented",
          "title": "File watcher fnmatch pattern syntax not exposed to users",
          "description": "backend/app/services/workflow_trigger_service.py: trigger file patterns use fnmatch but the supported syntax, examples, and limitations are not documented in the API or UI. Users cannot know if ** globs or relative paths are supported.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-structured-logging",
          "dimension": "usability",
          "slug": "no-structured-logging",
          "title": "Logs lack structured fields for correlation",
          "description": "All backend services log plain string messages without structured fields (execution_id, team_id, account_id). Adding structured JSON logging would allow filtering and correlating logs across services in any log aggregation tool.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-frontend-error-boundary",
          "dimension": "usability",
          "slug": "no-frontend-error-boundary",
          "title": "No error boundary prevents full SPA crashes",
          "description": "frontend/src/App.vue wraps the router-view but has no Vue error boundary component. A JavaScript error in any component can crash the entire single-page application, showing a blank screen instead of a useful error message.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-global-api-error-handler",
          "dimension": "usability",
          "slug": "no-global-api-error-handler",
          "title": "API error handling is duplicated across composables",
          "description": "Each composable in frontend/src/composables/ implements its own error handling and toast notification logic. A centralized API error handler would ensure consistent user feedback and reduce duplicated code across ~15 composables.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-null-checks-ai-chat",
          "dimension": "usability",
          "slug": "missing-null-checks-ai-chat",
          "title": "Missing null guards in AiChatPanel computed properties",
          "description": "frontend/src/composables/useAiChat.ts has computed properties that assume optional fields exist (e.g., `msg.backend` accessed without null check). Malformed SSE messages can cause runtime exceptions that crash the chat panel.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/poor-workflow-debugging-visibility",
          "dimension": "usability",
          "slug": "poor-workflow-debugging-visibility",
          "title": "Workflow execution lacks step-level observability",
          "description": "backend/app/services/workflow_execution_service.py executes complex multi-step workflows but logging is sparse. When a workflow fails mid-execution, there is insufficient log output to identify which step failed and why without adding debug statements.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/workflow-validation-error-clarity",
          "dimension": "usability",
          "slug": "workflow-validation-error-clarity",
          "title": "Workflow graph cycle error doesn't identify offending nodes",
          "description": "validate_workflow_graph() returns a generic 'Graph contains a cycle' message without indicating which node IDs form the cycle. Include the cycle path in the error for users to act on.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/undocumented-thread-safety",
          "dimension": "usability",
          "slug": "undocumented-thread-safety",
          "title": "Thread-safe data structures lack documentation",
          "description": "backend/app/services/execution_service.py uses _rate_limit_lock, _webhook_dedup_lock, and in-memory dicts but thread safety guarantees are undocumented. Add docstrings: 'Thread-safe: all access to _rate_limit_detected requires holding _rate_limit_lock.'",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/frontend-sse-reconnection-undocumented",
          "dimension": "usability",
          "slug": "frontend-sse-reconnection-undocumented",
          "title": "SSE reconnection backoff logic is undocumented",
          "description": "frontend/src/services/api/client.ts implements exponential backoff reconnection with SSE_INITIAL_DELAY_MS, SSE_MAX_ATTEMPTS constants but the algorithm and retry formula are not explained. Add a comment block describing the backoff behavior.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/webhook-field-matching-undocumented",
          "dimension": "usability",
          "slug": "webhook-field-matching-undocumented",
          "title": "Webhook field matching algorithm not documented",
          "description": "ExecutionService.dispatch_webhook_event() uses match_field_path and match_field_value for JSONPath-style matching but the matching rules and edge cases are not documented anywhere. Add examples to docstring or CLAUDE.md.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/vague-trigger-validation-errors",
          "dimension": "usability",
          "slug": "vague-trigger-validation-errors",
          "title": "Trigger validation returns generic error messages",
          "description": "backend/app/services/trigger_service.py lines 71-110 returns generic messages like 'name and prompt_template required' without indicating which specific field is missing. Scheduled trigger errors don't explain timezone or day-of-week format requirements.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-timeout-range-validation",
          "dimension": "usability",
          "slug": "no-timeout-range-validation",
          "title": "timeout_seconds accepts any value without range validation",
          "description": "backend/app/services/trigger_service.py accepts timeout_seconds with no min/max check. A user submitting 1s causes immediate timeouts; 99999s causes runaway processes. Failure only surfaces at runtime, not at creation.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/webhook-payload-size-no-details",
          "dimension": "usability",
          "slug": "webhook-payload-size-no-details",
          "title": "Payload too large error lacks size context",
          "description": "backend/app/routes/webhook.py lines 41-42 and backend/app/routes/github_webhook.py lines 74-75 return 'Payload too large' with no indication of actual vs. allowed size. Users can't tell how much to reduce their payload.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/retry-queue-not-visible",
          "dimension": "usability",
          "slug": "retry-queue-not-visible",
          "title": "Pending retry queue has no API endpoint",
          "description": "backend/app/services/execution_service.py schedule_retry() queues retries with no way for users to inspect them. Users can't distinguish between 'trigger is running', 'trigger is queued for retry', and 'trigger is stuck'.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/vague-health-check-errors",
          "dimension": "usability",
          "slug": "vague-health-check-errors",
          "title": "Health check returns raw SQL exception text",
          "description": "backend/app/routes/health.py readiness() lines 34-39 returns raw SQLite exception messages like 'database is locked' with no actionable guidance. Operators can't distinguish a transient lock from a corrupted database.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/sidebar-load-failures-silent",
          "dimension": "usability",
          "slug": "sidebar-load-failures-silent",
          "title": "Sidebar data load failures are invisible to users",
          "description": "frontend/src/App.vue lines 61-75: loadTriggers, loadProjects, loadProducts, loadTeams, loadPlugins, loadSidebarBackends all catch errors and log to console only. Users see empty/stale sidebars with no error message or retry button.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/conversation-silent-errors",
          "dimension": "usability",
          "slug": "conversation-silent-errors",
          "title": "Conversation operations silently fail",
          "description": "frontend/src/composables/useConversation.ts lines 287-305: checkActiveConversations() and abandonConversation() have empty catch blocks — failures produce no user feedback.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/workflow-error-ambiguity",
          "dimension": "usability",
          "slug": "workflow-error-ambiguity",
          "title": "Workflow version errors don't distinguish 404 from 400",
          "description": "backend/app/routes/workflows.py lines 142-144: Returns generic 400 BAD_REQUEST for both 'workflow not found' and 'invalid graph' cases, making client-side error handling and user messaging impossible.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-sidebar-loading-states",
          "dimension": "usability",
          "slug": "no-sidebar-loading-states",
          "title": "Sidebar renders partial content during concurrent async loads",
          "description": "frontend/src/App.vue lines 189-197: Seven async loads fire on mount with no coordinated loading state, skeleton placeholders, or progress indicator — the sidebar flickers in section by section.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/orchestration-launch-failed-ambiguous",
          "dimension": "usability",
          "slug": "orchestration-launch-failed-ambiguous",
          "title": "LAUNCH_FAILED result has null execution_id with no caller check",
          "description": "backend/app/services/orchestration_service.py lines 73-76: ExecutionResult.execution_id is None when status is LAUNCH_FAILED, but callers are not required to check the status discriminant before accessing the id.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-team-canvas-docs",
          "dimension": "usability",
          "slug": "missing-team-canvas-docs",
          "title": "Complex topology detection algorithms in useTeamCanvas.ts are undocumented",
          "description": "frontend/src/composables/useTeamCanvas.ts lines 246-577: findHubNode(), findTreeRoot(), findLinearChain() and related topology detection functions have no JSDoc comments, making the algorithms opaque to maintainers.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/resume-conversation-error-not-visible",
          "dimension": "usability",
          "slug": "resume-conversation-error-not-visible",
          "title": "resumeConversation failure not surfaced to the user",
          "description": "frontend/src/composables/useConversation.ts lines 279-282: `resumeConversation()` catches errors and returns `false` but does not set the `error` ref. The caller gets a boolean but the user sees no feedback about why resume failed, leaving them with a stale-looking conversation view.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/load-edges-error-silent",
          "dimension": "usability",
          "slug": "load-edges-error-silent",
          "title": "loadEdges failures silently leave org canvas empty",
          "description": "frontend/src/composables/useOrgCanvas.ts lines 67-69: `loadEdges()` catches and discards all errors. When edge loading fails (e.g., network error), the canvas renders with no connections between teams, with no toast, no error state, and no retry option visible to the user.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-loading-state-connect-stream",
          "dimension": "usability",
          "slug": "no-loading-state-connect-stream",
          "title": "connectStream sets no loading state before SSE connection",
          "description": "frontend/src/composables/useProjectSession.ts lines 137-139: `connectStream()` initiates an SSE connection but never sets `isLoading.value = true`. Components that depend on this composable have no way to show a loading indicator while waiting for the initial connection to be established.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/sse-queue-overflow-no-ui-feedback",
          "dimension": "usability",
          "slug": "sse-queue-overflow-no-ui-feedback",
          "title": "SSE backpressure overflow only logs to console",
          "description": "frontend/src/services/api/client.ts lines 240-245: when the SSE event queue overflows, only `console.warn` is called. The user has no indication that events are being dropped. A toast or status indicator would allow users to know they should check execution logs for missed updates.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/poor-cliproxy-error-message",
          "dimension": "usability",
          "slug": "poor-cliproxy-error-message",
          "title": "CLIProxy startup failure gives no actionable detail",
          "description": "backend/app/services/cliproxy_manager.py line 128: Generic 'Failed to start CLIProxyAPI' error doesn't indicate whether the binary is missing, has wrong permissions, or timed out on startup. Users cannot self-diagnose.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/api-client-error-message-bare-status",
          "dimension": "usability",
          "slug": "api-client-error-message-bare-status",
          "title": "API error falls back to bare HTTP status code",
          "description": "frontend/src/services/api/client.ts line 79: When response JSON is missing or malformed, the error message falls back to 'HTTP {status}'. Should include response body text to aid debugging.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/migration-failure-no-statement-context",
          "dimension": "usability",
          "slug": "migration-failure-no-statement-context",
          "title": "Migration failures don't identify failing statement",
          "description": "backend/app/db/migrations.py throughout: When a migration fails, the error doesn't indicate which SQL statement failed or what the schema state was before. Debugging schema mismatches in production requires manual inspection.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/no-request-logging-middleware",
          "dimension": "usability",
          "slug": "no-request-logging-middleware",
          "title": "No incoming API request logging",
          "description": "backend/app/__init__.py: No middleware logs incoming requests with method, path, status code, and response time. Diagnosing performance issues or unexpected errors in production requires digging through application logs with no request context.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/missing-env-var-validation-on-startup",
          "dimension": "usability",
          "slug": "missing-env-var-validation-on-startup",
          "title": "Missing environment variables fail silently at runtime",
          "description": "Multiple backend services read env vars like STALE_CONVERSATION_THRESHOLD_SECS without validation. Missing vars silently use defaults; mistyped vars silently use defaults. Should validate all required config at app startup with clear error messages.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/api-types-no-nullable-docs",
          "dimension": "usability",
          "slug": "api-types-no-nullable-docs",
          "title": "50+ API type interfaces lack documentation on nullable fields",
          "description": "frontend/src/services/api/types.ts: Defines 50+ TypeScript interfaces with no documentation on which fields are nullable, what defaults are, or what validation rules apply. Developers must inspect backend schema or guess.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 9.784615384615385,
      "effort": "large",
      "status": "pending"
    },
    {
      "id": "productivity/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "productivity",
      "title": "Miscellaneous (productivity)",
      "items": [
        {
          "id": "productivity/global-cache-with-bare-global-statement",
          "dimension": "productivity",
          "slug": "global-cache-with-bare-global-statement",
          "title": "Module-level cache managed with bare global statements",
          "description": "backend/app/services/plugin_deploy_service.py line 28 (definition), lines 418 and 451 (global statements): `_marketplace_cache` dict is managed via `global` keyword with no TTL enforcement or thread-safety. Hard to test and reason about.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/wildcard-import-database",
          "dimension": "productivity",
          "slug": "wildcard-import-database",
          "title": "Wildcard import hides database dependencies",
          "description": "backend/app/database.py lines 12 and 16-30: Uses `from app.db import *` followed by explicit re-imports. The wildcard import obscures what symbols are available, complicating static analysis and refactoring.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/run-trigger-god-function",
          "dimension": "productivity",
          "slug": "run-trigger-god-function",
          "title": "run_trigger() is a 190-line god function",
          "description": "backend/app/services/execution_service.py lines 261-450 handles path resolution, GitHub cloning, prompt template substitution, command building, process execution, error handling, and cleanup all in one function. Split into composable steps.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/orchestration-complex-fallback",
          "dimension": "productivity",
          "slug": "orchestration-complex-fallback",
          "title": "execute_with_fallback() is 170 lines with nested conditions",
          "description": "backend/app/services/orchestration_service.py lines 20-189 has deeply nested control flow with multiple return semantics (None for budget fail, None for retry scheduled, execution_id for success). Needs decomposition and explicit result types.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/create-app-monolith",
          "dimension": "productivity",
          "slug": "create-app-monolith",
          "title": "create_app() is a 209-line initialization monolith",
          "description": "backend/app/__init__.py lines 20-209 handles config, CORS, DB init, scheduler, monitoring, proxy manager, and cleanup handlers in one function. The initialization order is critical but not enforced or documented.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/large-service-files",
          "dimension": "productivity",
          "slug": "large-service-files",
          "title": "13 service files exceed 500 lines",
          "description": "backend/app/services/execution_service.py (877 lines), workflow_execution_service.py (859 lines), model_discovery_service.py (826 lines), cliproxy_manager.py (812 lines) each mix multiple concerns. Extract focused sub-services.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/large-app-vue",
          "dimension": "productivity",
          "slug": "large-app-vue",
          "title": "App.vue exceeds 1600 lines",
          "description": "frontend/src/App.vue is ~1681 lines combining layout, theme management, global state, toast notifications, and routing concerns. Extract sub-components and composables.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/schema-single-function",
          "dimension": "productivity",
          "slug": "schema-single-function",
          "title": "All DB schema in one 1262-line function",
          "description": "backend/app/db/schema.py contains a single `create_fresh_schema()` function with all table definitions. Hard to navigate and test schema changes for individual tables.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/monolithic-migrations-file",
          "dimension": "productivity",
          "slug": "monolithic-migrations-file",
          "title": "3,100-line monolithic migrations file",
          "description": "backend/app/db/migrations.py is 3,102 lines containing all schema migrations. Reviewing individual migrations is difficult, merge conflicts are frequent, and the file will keep growing. Should be split into versioned migration files (e.g., migrations/001_initial.py, migrations/002_add_agents.py).",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/massive-vue-components",
          "dimension": "productivity",
          "slug": "massive-vue-components",
          "title": "Vue components exceeding 1,000 lines",
          "description": "frontend/src/App.vue is 1,681 lines (mixes toast system, health polling, sidebar loading, navbar state). frontend/src/components/projects/ProjectLibraryTabs.vue is 1,481 lines. frontend/src/views/HarnessIntegration.vue is 1,383 lines. These should be decomposed into focused components and composables.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/large-conversation-service-functions",
          "dimension": "productivity",
          "slug": "large-conversation-service-functions",
          "title": "300+ line functions in agent conversation service",
          "description": "backend/app/services/agent_conversation_service.py has start_conversation() at line 139 (~304 lines) and send_message() at line 193 (~281 lines). These functions handle too many responsibilities and are difficult to unit test or debug.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/audit-service-giant-function",
          "dimension": "productivity",
          "slug": "audit-service-giant-function",
          "title": "_add_resolution_guidance() is 469 lines long",
          "description": "backend/app/services/audit_service.py:408 contains a single function `_add_resolution_guidance()` spanning ~469 lines. It violates the single responsibility principle and is extremely difficult to test, read, or modify without introducing bugs.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/execution-service-too-large",
          "dimension": "productivity",
          "slug": "execution-service-too-large",
          "title": "ExecutionService is ~900 lines with 4+ responsibilities",
          "description": "backend/app/services/execution_service.py is ~900 lines handling CLI command building (lines ~174-222), process lifecycle (lines ~263-572), auto-resolve PR flow (lines ~574-652), and webhook/GitHub dispatching (lines ~655-897). Each concern should be its own service.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/prompt-building-duplicated",
          "dimension": "productivity",
          "slug": "prompt-building-duplicated",
          "title": "Prompt building logic duplicated in two places",
          "description": "In backend/app/services/execution_service.py, prompt template substitution appears both in the trigger dispatch path (around line 299-326) and in the auto-resolve path (around line 591-603). Both use different patterns (chained .replace() vs hardcoded string). Should be unified into a single build_prompt() helper.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/rate-limit-detection-scattered",
          "dimension": "productivity",
          "slug": "rate-limit-detection-scattered",
          "title": "Rate limit detection logic scattered across 3 services",
          "description": "Rate limit detection appears in backend/app/services/execution_service.py (stderr scanning), rate_limit_service.py (cooldown tracking), and orchestration_service.py (fallback chain). Modifying rate limit behavior requires changes in all three places.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/execution-service-monolith",
          "dimension": "productivity",
          "slug": "execution-service-monolith",
          "title": "execution_service.py is 1,118 lines with monolithic dispatch method",
          "description": "backend/app/services/execution_service.py lines 470–680: dispatch_trigger mixes process setup, budget checks, timeout handling, and log streaming in one method. Extract _handle_process_timeout(), _wait_for_process_completion(), and _stream_output() to improve testability and readability.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/workflow-execution-service-dag",
          "dimension": "productivity",
          "slug": "workflow-execution-service-dag",
          "title": "workflow_execution_service.py DAG engine lacks decomposition",
          "description": "backend/app/services/workflow_execution_service.py is 884 lines. The _execute_dag method (~lines 150–400) combines topological sorting, node dispatching, and error recovery without separation. Extract _sort_nodes(), _dispatch_node(), and _collect_results() as standalone methods.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/team-canvas-composable-complexity",
          "dimension": "productivity",
          "slug": "team-canvas-composable-complexity",
          "title": "useTeamCanvas syncFromTeam() is overly nested",
          "description": "frontend/src/composables/useTeamCanvas.ts lines 45–150: syncFromTeam() has deeply nested conditionals for node/edge creation. Extract createAgentNodes(), createSuperAgentNodes(), and createConnectionEdges() to separate helper functions to reduce nesting.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/run-trigger-too-long",
          "dimension": "productivity",
          "slug": "run-trigger-too-long",
          "title": "run_trigger() method is 120+ lines",
          "description": "backend/app/services/execution_service.py:330-450 — run_trigger() handles prompt rendering, environment setup, process execution, and error handling in one method. Break into 4-5 focused helpers.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/stream-subprocess-output-complexity",
          "dimension": "productivity",
          "slug": "stream-subprocess-output-complexity",
          "title": "_stream_subprocess_output() has deeply nested logic",
          "description": "backend/app/services/execution_service.py:550-850 — Nested try-except blocks with threading logic. Extract stream handlers into dedicated methods to reduce cognitive load.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/execute-with-fallback-too-long",
          "dimension": "productivity",
          "slug": "execute-with-fallback-too-long",
          "title": "execute_with_fallback() exceeds 170 lines",
          "description": "backend/app/services/orchestration_service.py:48-225 — Complex chain iteration, rate limit checking, and account rotation in a single method. Decompose into account selection, execution, and fallback handling.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/send-chat-message-monolith",
          "dimension": "productivity",
          "slug": "send-chat-message-monolith",
          "title": "send_chat_message() endpoint is 190 lines",
          "description": "backend/app/routes/super_agents.py:352-541 — Single endpoint handles session management, backend routing, mode dispatch (all/compound/single), and thread launching. Each concern should be a separate function.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/migrations-monolith",
          "dimension": "productivity",
          "slug": "migrations-monolith",
          "title": "migrations.py is a 3200+ line monolith",
          "description": "backend/app/db/migrations.py — Single file contains all migration logic. Should be split into versioned modules (migrations/v1.py, migrations/v2.py, etc.) for maintainability and easier debugging.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/process-with-claude-mixed-concerns",
          "dimension": "productivity",
          "slug": "process-with-claude-mixed-concerns",
          "title": "_process_with_claude() mixes streaming, accumulation, and persistence",
          "description": "backend/app/services/base_conversation_service.py:282-354 — LLM streaming, text accumulation, and DB persistence are handled in one method. Separating concerns would make each testable independently.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/run-trigger-god-method",
          "dimension": "productivity",
          "slug": "run-trigger-god-method",
          "title": "ExecutionService.run_trigger() is a 280+ line god method",
          "description": "backend/app/services/execution_service.py lines 417-700+: a single method handles placeholder replacement (60+ lines), environment setup, process management, output streaming, budget checks, and auto-resolve PR flows. Should be split into focused private helpers.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/dispatch-webhook-duplication",
          "dimension": "productivity",
          "slug": "dispatch-webhook-duplication",
          "title": "Duplicate trigger-matching logic in dispatch_webhook_event()",
          "description": "backend/app/services/execution_service.py lines 874-1002: nearly identical loops for matching triggers and teams against webhook payloads. Extracting a shared `match_entity_to_payload()` helper would eliminate ~60 lines of duplicated code.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/large-harness-integration-component",
          "dimension": "productivity",
          "slug": "large-harness-integration-component",
          "title": "HarnessIntegration.vue is 1383 lines",
          "description": "frontend/src/views/HarnessIntegration.vue (1383 lines): a monolithic component handling connection management, project scanning, library imports, and error states. Should be split into focused sub-components to improve testability and maintainability.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/execution-service-god-class",
          "dimension": "productivity",
          "slug": "execution-service-god-class",
          "title": "execution_service.py is a 1180-line god class",
          "description": "backend/app/services/execution_service.py: run_trigger() spans lines 448-650 (200+ lines) mixing GitHub cloning, prompt template rendering, subprocess spawning, log streaming, rate-limit detection, and cleanup. Should be split into TriggerPromptBuilder, SubprocessExecutor, RateLimitDetector, StreamLogCollector.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/workflow-execution-service-god-class",
          "dimension": "productivity",
          "slug": "workflow-execution-service-god-class",
          "title": "workflow_execution_service.py mixes DAG, dispatch, and node handling",
          "description": "backend/app/services/workflow_execution_service.py (922 lines): DAG graph validation, topological sort, node dispatch, and per-node handlers are all intermingled with no clear separation. Extract graph logic and node handlers into dedicated modules.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/model-discovery-no-strategy-pattern",
          "dimension": "productivity",
          "slug": "model-discovery-no-strategy-pattern",
          "title": "model_discovery_service.py duplicates logic per provider",
          "description": "backend/app/services/model_discovery_service.py (826 lines): 10+ discovery methods for Claude, Codex, Gemini, OpenCode each repeat API call, file parsing, and config handling. A provider strategy pattern would halve the code.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/dynamic-sql-set-clauses",
          "dimension": "productivity",
          "slug": "dynamic-sql-set-clauses",
          "title": "Dynamic SQL SET clauses built with f-strings across DB layer",
          "description": "backend/app/db/agents.py:203, backends.py:384, commands.py:77, grd.py:98,289, hooks.py:69, mcp_servers.py:146: UPDATE statements use f\"SET {', '.join(updates)}\" with dynamic column names. Values are parameterized but column names are free strings — fragile and hard to audit.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/workflow-execution-service-complexity",
          "dimension": "productivity",
          "slug": "workflow-execution-service-complexity",
          "title": "WorkflowExecutionService is 921 lines with deep nesting",
          "description": "backend/app/services/workflow_execution_service.py contains complex branching logic with deeply nested conditionals. Step execution, condition evaluation, and looping logic are interleaved, making it difficult to follow execution paths.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/monitoring-service-complex-state",
          "dimension": "productivity",
          "slug": "monitoring-service-complex-state",
          "title": "MonitoringService manages too much mutable class-level state",
          "description": "backend/app/services/monitoring_service.py maintains multiple class-level dicts (`_last_threshold_levels`, `_recent_alerts`, `_last_polled_at`, `_consecutive_poll_failures`) with no clear lifecycle management, making unit testing and state isolation difficult.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/large-route-files",
          "dimension": "productivity",
          "slug": "large-route-files",
          "title": "Route files exceed reasonable size with no sub-grouping",
          "description": "backend/app/routes/teams.py (771 lines), backend/app/routes/super_agents.py (648 lines), and backend/app/routes/workflows.py are too large. Route handlers share a file but have no logical sub-grouping, increasing cognitive load when navigating.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/execution-service-bloat",
          "dimension": "productivity",
          "slug": "execution-service-bloat",
          "title": "ExecutionService combines too many responsibilities",
          "description": "backend/app/services/execution_service.py is 1,347 lines combining webhook dispatch, rate-limit retry scheduling, CLI command building, budget monitoring, and process streaming in one class. Should split into DispatchService, RetryScheduler, CommandBuilder, and ProcessMonitor.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/large-db-migrations-file",
          "dimension": "productivity",
          "slug": "large-db-migrations-file",
          "title": "Database migrations file is 3,180 lines",
          "description": "backend/app/db/migrations.py is a single 3,180-line file with repetitive migration logic. Should be split into version-specific modules or use a migration builder pattern to reduce cognitive overhead.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/schema-file-too-long",
          "dimension": "productivity",
          "slug": "schema-file-too-long",
          "title": "Database schema file lacks modularization",
          "description": "backend/app/db/schema.py (1,294 lines) contains all table definitions in a single file. Should split by domain (agents, triggers, workflows, teams) for maintainability.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/long-db-triggers-file",
          "dimension": "productivity",
          "slug": "long-db-triggers-file",
          "title": "Triggers CRUD module exceeds 1,100 lines",
          "description": "backend/app/db/triggers.py (1,109 lines) mixes trigger CRUD, path operations, symlink management, and PR reviews. Split into trigger_crud.py, trigger_paths.py, trigger_symlinks.py, pr_reviews.py.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/workflow-execution-dag-complexity",
          "dimension": "productivity",
          "slug": "workflow-execution-dag-complexity",
          "title": "Workflow DAG traversal logic is overly complex",
          "description": "backend/app/services/workflow_execution_service.py is 921 lines with deeply nested loop logic for DAG traversal, node dependency resolution, and state management using raw dicts instead of typed classes. Makes it difficult to add new node types or parallelize execution.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/trigger-template-rendering-mixed",
          "dimension": "productivity",
          "slug": "trigger-template-rendering-mixed",
          "title": "Prompt template substitution mixed into execution dispatch",
          "description": "backend/app/services/execution_service.py mixes prompt template rendering (multiple placeholder formats: {path}, {message}, {pr_url}) with execution dispatch logic, making it hard to add new triggers without understanding the full string replacement chain.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/workflow-execution-monolith",
          "dimension": "productivity",
          "slug": "workflow-execution-monolith",
          "title": "workflow_execution_service.py has a 320-line core method",
          "description": "backend/app/services/workflow_execution_service.py: _run_workflow() spans lines 278-598 (~320 lines). Node handlers (_execute_*_node) should be extracted into strategy classes.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/print-instead-of-logger-migrations",
          "dimension": "productivity",
          "slug": "print-instead-of-logger-migrations",
          "title": "print() statements instead of logger in migrations.py",
          "description": "backend/app/db/migrations.py lines 134, 187 and throughout: uses `print()` for warnings like 'WAL mode not enabled' and execution cleanup counts. These messages are invisible in production log aggregators and can't be filtered by log level. Replace with `logger.warning()` / `logger.info()`.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/create-backoff-eventsource-too-long",
          "dimension": "productivity",
          "slug": "create-backoff-eventsource-too-long",
          "title": "createBackoffEventSource is 186-line monolithic function",
          "description": "frontend/src/services/api/client.ts lines 160-346: `createBackoffEventSource()` handles reconnection logic, event listener proxying, backpressure queue management, and Retry-After header parsing all in one function. Each concern should be extracted into a separate helper to enable unit testing and reduce cognitive load.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/handle-state-delta-long-switch",
          "dimension": "productivity",
          "slug": "handle-state-delta-long-switch",
          "title": "handleStateDelta switch statement is 112 lines",
          "description": "frontend/src/composables/useAiChat.ts lines 279-390: `handleStateDelta()` contains a switch with 6+ cases each containing nested business logic. Each case handler (e.g., 'agent_start', 'tool_use', 'message_delta') should be extracted into a named function to improve readability and testability.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/router-guard-duplication",
          "dimension": "productivity",
          "slug": "router-guard-duplication",
          "title": "12 duplicated router guard validators with identical structure",
          "description": "frontend/src/router/guards.ts lines 22-59: each entity validator (bot, agent, project, team, plugin, etc.) repeats the same try/catch/redirect pattern. A `makeEntityValidator(fetchFn, redirectRoute)` factory function would reduce this to a single definition per entity.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/sketch-chat-duplicate-json-parsing",
          "dimension": "productivity",
          "slug": "sketch-chat-duplicate-json-parsing",
          "title": "Duplicate JSON extraction logic in useSketchChat",
          "description": "frontend/src/composables/useSketchChat.ts lines 68-78, 113-123, 157-174, 176-193: the same 'extract JSON block from markdown, parse it, pick fields' pattern is repeated 4 times for different response types (classification, routing, component generation). Extract a single `parseJsonBlock(text)` helper.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/settimeout-zero-hack-workflow-canvas",
          "dimension": "productivity",
          "slug": "settimeout-zero-hack-workflow-canvas",
          "title": "setTimeout(0) used to defer flag reset in useWorkflowCanvas",
          "description": "frontend/src/composables/useWorkflowCanvas.ts line 138-141: `setTimeout(() => { _loading = false }, 0)` defers a flag reset to avoid a race condition rather than solving the underlying cause. This is a timing-dependent hack that can break under load or in test environments.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/workflow-trigger-service-too-large",
          "dimension": "productivity",
          "slug": "workflow-trigger-service-too-large",
          "title": "workflow_trigger_service.py handles 4 unrelated trigger types",
          "description": "backend/app/services/workflow_trigger_service.py is 819 lines implementing completion triggers, cron triggers, polling triggers, and file watch triggers in a single class. Each trigger strategy should be its own class implementing a common interface to enable independent testing and modification.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/execution-service-run-trigger-split",
          "dimension": "productivity",
          "slug": "execution-service-run-trigger-split",
          "title": "Split monolithic run_trigger() method",
          "description": "backend/app/services/execution_service.py: run_trigger() spans ~300 lines (approx lines 573-900) handling repo cloning, template rendering, placeholder replacement, prompt building, command execution, and budget checks all in one method. Split into focused helpers: clone_repos(), render_prompt(), build_command(), execute_process().",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "productivity/migrations-file-too-large",
          "dimension": "productivity",
          "slug": "migrations-file-too-large",
          "title": "Split 3200-line migrations file",
          "description": "backend/app/db/migrations.py is ~3200 lines. Should be split into version-range modules (e.g., migrations_v1.py, migrations_v2.py) or use a migration builder utility to reduce cognitive load and merge conflicts.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 9.7,
      "effort": "large",
      "status": "pending"
    },
    {
      "id": "usability/error-messages",
      "theme": "error-messages",
      "dimension": "usability",
      "title": "Error Messages (usability)",
      "items": [
        {
          "id": "usability/generic-error-messages-routes",
          "dimension": "usability",
          "slug": "generic-error-messages-routes",
          "title": "Route error responses lack specific failure context",
          "description": "backend/app/routes/super_agents.py line ~88 and backend/app/routes/teams.py lines 87–98 return generic 'Failed to create...' or 'Error' messages. Callers cannot distinguish DB errors from validation failures from permission errors. Add error codes or structured error bodies.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "usability/generic-error-responses",
          "dimension": "usability",
          "slug": "generic-error-responses",
          "title": "Generic error messages prevent client-side debugging",
          "description": "backend/app/__init__.py:233 returns {\"error\": \"Internal server error\"} for all unhandled exceptions. Clients cannot distinguish validation errors, auth failures, budget exhaustion, or server crashes. Should return structured error codes (e.g. VALIDATION_ERROR, BUDGET_EXHAUSTED).",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 9,
      "effort": "small",
      "status": "pending"
    },
    {
      "id": "quality/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "quality",
      "title": "Miscellaneous (quality)",
      "items": [
        {
          "id": "quality/execution-service-too-large",
          "dimension": "quality",
          "slug": "execution-service-too-large",
          "title": "execution_service.py is 748 lines of mixed concerns",
          "description": "backend/app/services/execution_service.py (748 lines): Combines trigger dispatching, command building, subprocess orchestration, rate-limit tracking, and log streaming in a single class. Extract subprocess management and log streaming into separate modules.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/workflow-execution-service-too-large",
          "dimension": "quality",
          "slug": "workflow-execution-service-too-large",
          "title": "workflow_execution_service.py is 857 lines",
          "description": "backend/app/services/workflow_execution_service.py (857 lines): Manages DAG execution, node states, retries, and error modes with complex in-memory threading. Extremely difficult to test individual node execution or retry logic in isolation.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/team-execution-service-too-large",
          "dimension": "quality",
          "slug": "team-execution-service-too-large",
          "title": "team_execution_service.py is 764 lines",
          "description": "backend/app/services/team_execution_service.py (764 lines): Mixed concerns — team routing, message passing, in-memory state, and subprocess orchestration. Locks at lines 33-35 guard shared state accessed in complex call chains.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/teams-route-too-large",
          "dimension": "quality",
          "slug": "teams-route-too-large",
          "title": "teams.py route file is 681 lines",
          "description": "backend/app/routes/teams.py (681 lines): Single route file handles team CRUD, topology generation, member management, and execution triggers. Should be split into focused sub-blueprints (e.g., teams_crud, teams_execution, teams_topology).",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/super-agents-route-too-large",
          "dimension": "quality",
          "slug": "super-agents-route-too-large",
          "title": "super_agents.py route file is 628 lines",
          "description": "backend/app/routes/super_agents.py (628 lines): Handles super agents, documents, sessions, and message routing in one file. Each concern should have its own route file.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/migrations-file-3000-lines",
          "dimension": "quality",
          "slug": "migrations-file-3000-lines",
          "title": "migrations.py is 3102 lines and hard to navigate",
          "description": "backend/app/db/migrations.py (3102 lines): Entire migration history in a single file. While append-only is intentional, grouping migrations by phase or domain (e.g., migrations_v1.py, migrations_v2.py) would improve discoverability and reduce diff noise.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-frontend-unit-tests",
          "dimension": "quality",
          "slug": "missing-frontend-unit-tests",
          "title": "Frontend components have near-zero unit test coverage",
          "description": "frontend/src/components/ and frontend/src/views/: 182 Vue components exist but test coverage is minimal. Only ~10 test files were found. Core views like execution flows, agent management, and workflow editors have no unit tests.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-backend-integration-tests",
          "dimension": "quality",
          "slug": "no-backend-integration-tests",
          "title": "No integration tests for multi-service workflows",
          "description": "backend/tests/: 49 test files present but appear to be unit tests only. No integration tests covering the full execution pipeline — trigger → dispatch → subprocess → log streaming → status update.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/print-instead-of-logging",
          "dimension": "quality",
          "slug": "print-instead-of-logging",
          "title": "print() used instead of logger throughout services",
          "description": "backend/app/services/execution_service.py lines 167, 233, 241-243, 256, 285, 336-337 and github_service.py lines 76, 93, 96, 100, 104, 108, 114 use print(). These bypass logging config and won't appear in production log aggregation.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-execution-errors",
          "dimension": "quality",
          "slug": "missing-tests-execution-errors",
          "title": "No tests for ExecutionService error paths",
          "description": "backend/tests/ has no coverage for run_trigger() GitHub clone failures, prompt substitution edge cases, subprocess failure handling, or rate-limit detection in stderr parsing. These are the most critical paths.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-concurrent",
          "dimension": "quality",
          "slug": "missing-tests-concurrent",
          "title": "No tests for concurrent/threaded operations",
          "description": "Services using `_lock` threading (execution_service.py, execution_log_service.py, process_manager.py) have no concurrency tests. Threading bugs only surface under load.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-budget-boundary",
          "dimension": "quality",
          "slug": "missing-tests-budget-boundary",
          "title": "No tests for budget enforcement boundaries",
          "description": "Budget enforcement logic in orchestration_service.py has no tests for boundary conditions (exactly at limit, just over, negative balance). Critical for billing correctness.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/todo-fixme-markers",
          "dimension": "quality",
          "slug": "todo-fixme-markers",
          "title": "Unresolved TODO/FIXME markers in production code",
          "description": "Multiple service files contain TODO/FIXME comments representing deferred work. Run `grep -rn 'TODO\\|FIXME' backend/app/` to enumerate them all and prioritize resolution.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-route-tests",
          "dimension": "quality",
          "slug": "missing-route-tests",
          "title": "40%+ of API route files have no tests",
          "description": "No test files exist for: backend/app/routes/agents.py, routes/backends.py, routes/plugins.py, routes/executions.py, routes/workflows.py, routes/grd.py, and ~20 other route files. API changes risk undetected regressions across core functionality.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-app-vue-tests",
          "dimension": "quality",
          "slug": "missing-app-vue-tests",
          "title": "No tests for App.vue (main layout/state)",
          "description": "frontend/src/App.vue manages global toast notifications, health polling, sidebar loading, and navigation state — but has zero test coverage. Changes to this file risk breaking the entire application shell silently.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/frontend-type-safety-gaps",
          "dimension": "quality",
          "slug": "frontend-type-safety-gaps",
          "title": "Type safety bypassed with `any` casts in tests",
          "description": "frontend/src/webmcp/__tests__/search-sort-cycle.test.ts:81,88,93,100,111,121,131,135 uses multiple `as any` casts. frontend/src/webmcp/useWebMcpPageTools.ts:27,37,43,67,127 uses `Record<string, unknown>` loosely. Tests won't catch type-related regressions.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/deprecated-fields-no-timeline",
          "dimension": "quality",
          "slug": "deprecated-fields-no-timeline",
          "title": "Deprecated fields with no removal timeline",
          "description": "backend/app/services/trigger_service.py:66 retains a deprecated field for backward compatibility with no comment about when it will be removed. These fields accumulate over time and complicate the data model.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-monitoring-section-tests",
          "dimension": "quality",
          "slug": "missing-monitoring-section-tests",
          "title": "MonitoringSection.vue (1,202 lines) has no unit tests",
          "description": "frontend/src/components/monitoring/MonitoringSection.vue is a large, complex monitoring dashboard component with no corresponding test file. Changes to monitoring logic, chart rendering, or panel state cannot be validated automatically.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/scheduler-init-too-large",
          "dimension": "quality",
          "slug": "scheduler-init-too-large",
          "title": "Scheduler init function spans 330+ lines",
          "description": "backend/app/services/agent_scheduler_service.py's init function is ~330 lines. Scheduler initialization phases (DB connection, job registration, trigger loading, cron parsing) are all intermixed. This is a coverage and maintainability concern.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/print-statements-not-logging",
          "dimension": "quality",
          "slug": "print-statements-not-logging",
          "title": "print() used instead of logger across multiple services",
          "description": "backend/app/services/execution_service.py, github_service.py, and other services use print() for operational messages (26+ instances). Production deployments capture structured logs but not stdout, making these messages invisible in any real deployment.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-for-plugin-sync-service",
          "dimension": "quality",
          "slug": "no-tests-for-plugin-sync-service",
          "title": "plugin_sync_service.py has no test file",
          "description": "backend/app/services/plugin_sync_service.py has no corresponding test file. Plugin sync is a core feature (syncing skills/hooks/commands from filesystem into DB) with no automated coverage.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-for-worktree-service",
          "dimension": "quality",
          "slug": "no-tests-for-worktree-service",
          "title": "worktree_service.py has no test file",
          "description": "backend/app/services/worktree_service.py has no corresponding test file. Worktree operations involve git subprocess calls and filesystem mutations — high-risk code without any test coverage.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-for-rate-limit-service",
          "dimension": "quality",
          "slug": "no-tests-for-rate-limit-service",
          "title": "rate_limit_service.py has no test file",
          "description": "backend/app/services/rate_limit_service.py has no dedicated test file. Rate limit logic is critical for preventing overuse of expensive API calls and directly affects system stability.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-for-grd-sync-service",
          "dimension": "quality",
          "slug": "no-tests-for-grd-sync-service",
          "title": "grd_sync_service.py has no test file",
          "description": "backend/app/services/grd_sync_service.py has no dedicated test file despite being responsible for syncing GRD planning state — a complex multi-step operation with side effects.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-for-audit-log-service",
          "dimension": "quality",
          "slug": "no-tests-for-audit-log-service",
          "title": "audit_log_service.py (new, untracked) has no tests",
          "description": "backend/app/services/audit_log_service.py is currently untracked (shown in git status as ??). It has no test file. New services should ship with tests before being integrated.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/frontend-no-error-boundary",
          "dimension": "quality",
          "slug": "frontend-no-error-boundary",
          "title": "Vue app has no global error boundary or error reporting",
          "description": "frontend/src/App.vue and main.ts do not configure a Vue errorHandler or any error boundary component. Uncaught component errors in child views will silently fail or crash the entire SPA with only a browser console error.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/frontend-api-no-request-cancellation",
          "dimension": "quality",
          "slug": "frontend-api-no-request-cancellation",
          "title": "Frontend API calls not cancelled on component unmount",
          "description": "In frontend/src/services/api.ts, fetch calls do not use AbortController. When a user navigates away mid-request, the request continues and may update stale component state or cause 'component unmounted' Vue warnings.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-model-discovery",
          "dimension": "quality",
          "slug": "missing-tests-model-discovery",
          "title": "model_discovery_service.py has no tests",
          "description": "backend/app/services/model_discovery_service.py (826 lines) has no corresponding test file. This service handles model enumeration for claude/opencode/gemini and is a critical path. Add tests covering discovery, caching, and failure fallback behavior.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-cliproxy-manager",
          "dimension": "quality",
          "slug": "missing-tests-cliproxy-manager",
          "title": "cliproxy_manager.py has no tests",
          "description": "backend/app/services/cliproxy_manager.py (812 lines) has no test coverage. Covers process lifecycle, config management, and health checks. Add unit tests with mocked subprocess calls for start/stop/health-check flows.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-composables",
          "dimension": "quality",
          "slug": "missing-tests-composables",
          "title": "Major Vue composables have no tests",
          "description": "frontend/src/composables/useTeamCanvas.ts (576 lines), useAiChat.ts (427 lines), and useConversation.ts (352 lines) have no test files. These are core UI logic units; add Vitest tests covering state transitions and SSE handling.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-backend-service",
          "dimension": "quality",
          "slug": "missing-tests-backend-service",
          "title": "backend_service.py and workflow_trigger_service.py have no tests",
          "description": "backend/app/services/backend_service.py and backend/app/services/workflow_trigger_service.py lack test coverage. backend_service.py handles account creation and proxy lifecycle; missing tests means regressions go undetected.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-core-services",
          "dimension": "quality",
          "slug": "missing-tests-core-services",
          "title": "No tests for orchestration, rotation, scheduling, and budget services",
          "description": "backend/tests/ — orchestration_service.py, rotation_service.py, agent_scheduler_service.py, budget_service.py, and github_service.py have zero test coverage despite handling core platform features.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/silent-test-setup-failures",
          "dimension": "quality",
          "slug": "silent-test-setup-failures",
          "title": "Test fixture silently swallows import errors",
          "description": "backend/tests/conftest.py:62-76 — reset_github_webhook_rate_limit() uses bare except-pass blocks that silently swallow import errors, making test setup failures invisible and hard to debug.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/print-instead-of-logger",
          "dimension": "quality",
          "slug": "print-instead-of-logger",
          "title": "Widespread use of print() instead of structured logging",
          "description": "backend/app/services/execution_service.py:79,114,139,150,174,323,389,397,412 and backend/app/services/github_service.py:79,97,114,139,150,152,174,176 — Dozens of print() calls instead of logger. Log output is invisible in production deployments.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-frontend-composables",
          "dimension": "quality",
          "slug": "missing-tests-frontend-composables",
          "title": "No tests for useAiChat composable",
          "description": "frontend/src/composables/useAiChat.ts — Core chat composable handling SSE streaming, session management, and conversation state has no test coverage. Behavior regressions go undetected.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-error-boundary-components",
          "dimension": "quality",
          "slug": "no-error-boundary-components",
          "title": "No Vue error boundary components",
          "description": "frontend/src/ — No error boundary components to catch and display Vue rendering errors. SSE streaming errors in chat and execution log viewers fail silently with no user feedback.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-run-trigger-substitution",
          "dimension": "quality",
          "slug": "missing-tests-run-trigger-substitution",
          "title": "No tests for webhook payload placeholder substitution",
          "description": "backend/tests/: there are no tests covering ExecutionService.run_trigger() placeholder replacement logic ({paths}, {message}, {pr_url}, etc.), a critical path that determines what prompt is sent to the AI.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-hmac-edge-cases",
          "dimension": "quality",
          "slug": "missing-tests-hmac-edge-cases",
          "title": "No tests for webhook HMAC validation edge cases",
          "description": "backend/tests/: webhook HMAC validation lacks tests for malformed signatures, missing headers, timing-safe comparison, and replay attacks. Only happy-path webhook delivery is tested.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-rate-limit-retry",
          "dimension": "quality",
          "slug": "missing-tests-rate-limit-retry",
          "title": "No tests for concurrent rate-limit retry scheduling",
          "description": "backend/tests/: ExecutionService.schedule_retry() and the rate-limit backoff logic (lines 98-164) have no test coverage, leaving race conditions and retry-loop bugs undetected.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/undocumented-placeholders",
          "dimension": "quality",
          "slug": "undocumented-placeholders",
          "title": "Placeholder substitution list undocumented",
          "description": "backend/app/services/execution_service.py lines 450-481: _KNOWN_PLACEHOLDERS set is hardcoded with no documentation on what each placeholder resolves to, how to add new ones, or where they are populated from in webhook payloads.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-provider-usage-client",
          "dimension": "quality",
          "slug": "no-tests-provider-usage-client",
          "title": "provider_usage_client.py (626 lines) has zero tests",
          "description": "backend/app/services/provider_usage_client.py: token usage tracking across providers has no dedicated test file despite being critical to budget enforcement. Add unit tests for all provider adapters and aggregation logic.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-project-session-manager",
          "dimension": "quality",
          "slug": "no-tests-project-session-manager",
          "title": "project_session_manager.py (725 lines) has zero tests",
          "description": "backend/app/services/project_session_manager.py: complex session state machine with no test coverage. Session state transitions, concurrent access, and timeout logic are entirely unverified.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/execution-service-minimal-tests",
          "dimension": "quality",
          "slug": "execution-service-minimal-tests",
          "title": "ExecutionService tested only for token usage, not core flow",
          "description": "backend/tests/: only 3 tests cover ExecutionService (token extraction, no-usage-data, budget precheck). The main run_trigger() path, rate-limit retry logic, restore_pending_retries(), and error branches have no tests.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-useAiChat-composable",
          "dimension": "quality",
          "slug": "no-tests-useAiChat-composable",
          "title": "useAiChat.ts composable has no frontend tests",
          "description": "frontend/src/composables/useAiChat.ts: chat streaming composable — the most user-visible real-time feature — has no Vitest tests covering SSE parsing, reconnection, error states, or message accumulation.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-team-monitor-service",
          "dimension": "quality",
          "slug": "no-tests-team-monitor-service",
          "title": "team_monitor_service.py (220 lines) has no tests",
          "description": "backend/app/services/team_monitor_service.py: extensive exception handling paths, monitor lifecycle, and state transitions are all untested. Exception handling bugs here would silently degrade team monitoring.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-rate-limit-retry-restore",
          "dimension": "quality",
          "slug": "no-tests-rate-limit-retry-restore",
          "title": "Rate-limit retry restoration on restart is untested",
          "description": "backend/app/services/execution_service.py lines 214-295: restore_pending_retries() is called on startup to reschedule pending retries after a crash, but there are no tests verifying that retries are correctly persisted, loaded, and rescheduled.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/migrations-dynamic-table-name-fstring",
          "dimension": "quality",
          "slug": "migrations-dynamic-table-name-fstring",
          "title": "Migration uses f-string for table names in SQL",
          "description": "backend/app/db/migrations.py lines 344-349: f\"INSERT INTO {table_name}_new SELECT * FROM {table_name}\" uses dynamic table names from internal code, but this pattern is fragile and sets a bad precedent. Should validate table_name against an allowlist before constructing SQL.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-mcp-sync-service",
          "dimension": "quality",
          "slug": "no-tests-mcp-sync-service",
          "title": "mcp_sync_service.py has no test coverage",
          "description": "backend/app/services/mcp_sync_service.py: MCP server synchronization logic is untested. Sync failures and partial-sync states could silently leave MCP configuration inconsistent.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-skill-discovery",
          "dimension": "quality",
          "slug": "no-tests-skill-discovery",
          "title": "skill_discovery_service.py has no tests",
          "description": "backend/app/services/skill_discovery_service.py: skill file parsing, discovery, and registration logic has no test coverage. Malformed skill files or filesystem edge cases are unverified.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-conversation-service-tests",
          "dimension": "quality",
          "slug": "missing-conversation-service-tests",
          "title": "Core conversation services have no unit tests",
          "description": "Critical services like backend/app/services/agent_conversation_service.py, backend/app/services/base_conversation_service.py, backend/app/services/session_collection_service.py have no corresponding test files. These are on the critical execution path.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-db-crud-tests",
          "dimension": "quality",
          "slug": "missing-db-crud-tests",
          "title": "Database CRUD operations lack test coverage",
          "description": "backend/app/db/triggers.py (1109 lines) and backend/app/db/workflows.py have complex CRUD logic but minimal test coverage. backend/tests/ has no dedicated tests for these modules, risking silent data corruption.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-frontend-component-tests",
          "dimension": "quality",
          "slug": "missing-frontend-component-tests",
          "title": "Most Vue components have no tests",
          "description": "frontend/src/ has 100+ Vue components but only ~29 test files. Workflow canvas components, monitoring charts, and most route-level views have no tests. Visual regressions and logic errors go undetected.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/audit-log-coverage-gaps",
          "dimension": "quality",
          "slug": "audit-log-coverage-gaps",
          "title": "Audit logging not verified for all destructive operations",
          "description": "backend/app/services/audit_log_service.py exists but there is no mechanism to verify every `delete_*` function in backend/app/db/ calls it. Destructive operations may go unaudited, leaving no trace of who deleted what.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-retry-logic-tests",
          "dimension": "quality",
          "slug": "missing-retry-logic-tests",
          "title": "No tests for rate-limit retry scheduling",
          "description": "ExecutionService.schedule_retry() and restore_pending_retries() are complex state-management functions with closure-based timers and DB persistence but have no dedicated tests. Need tests for exponential backoff, timer cancellation, thread safety, and DB round-trips.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/workflow-error-mode-tests-missing",
          "dimension": "quality",
          "slug": "workflow-error-mode-tests-missing",
          "title": "Workflow node error modes lack targeted tests",
          "description": "Workflow node error modes (stop, continue, continue_with_error) each have distinct branching paths in WorkflowExecutionService, but test coverage for edge cases (node timeout + continue_with_error, cycle detection + partial execution) is missing.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-input-validation",
          "dimension": "quality",
          "slug": "missing-input-validation",
          "title": "Insufficient request body validation in routes",
          "description": "Route handlers in backend/app/routes/ accept request.get_json() but validate fields minimally before passing to DB. No schema validation for nested objects, array bounds, or type coercion. Should use Pydantic models for all request bodies.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/async-services-not-tested",
          "dimension": "quality",
          "slug": "async-services-not-tested",
          "title": "Background services not initialized in tests",
          "description": "backend/app/__init__.py spawns SchedulerService, MonitoringService, RotationEvaluator, CLIProxyManager only in non-testing mode. Their behavior is untested in conftest.py, creating gaps in integration coverage.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-orchestration-tests",
          "dimension": "quality",
          "slug": "missing-orchestration-tests",
          "title": "No tests for orchestration_service.py",
          "description": "backend/app/services/orchestration_service.py (~290 lines) has no dedicated test file. Critical paths like all-backends-rate-limited fallback, account selection between specific and auto-pick modes, and budget-check-triggered retry scheduling are completely untested.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/webhook-tests-missing-edge-cases",
          "dimension": "quality",
          "slug": "webhook-tests-missing-edge-cases",
          "title": "GitHub webhook tests missing critical edge cases",
          "description": "backend/tests/test_github_webhook.py covers basic scenarios but is missing: HMAC signature verification failures, malformed PR data, per-repo rate limiting under concurrent events, and retry scheduling behavior.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/budget-token-extraction-untested",
          "dimension": "quality",
          "slug": "budget-token-extraction-untested",
          "title": "Token extraction in budget_service is untested",
          "description": "backend/app/services/budget_service.py lines 92-114 uses fragile regex + JSON scanning for token parsing. No tests for mixed stdout/stderr, timeout scenarios, or truncated output — wrong token counts lead to incorrect budget tracking.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/frontend-sse-reconnect-untested",
          "dimension": "quality",
          "slug": "frontend-sse-reconnect-untested",
          "title": "SSE backoff and reconnect logic lacks tests",
          "description": "frontend/src/services/api/client.ts createBackoffEventSource() implements exponential backoff with jitter but has no tests for: backpressure queue overflow, event loss during reconnection, or jitter calculation correctness.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-orchestration-service",
          "dimension": "quality",
          "slug": "no-tests-orchestration-service",
          "title": "orchestration_service.py has no dedicated unit tests",
          "description": "backend/app/services/orchestration_service.py contains fallback chain logic and execution dispatch but has no test file. The validate_fallback_chain_entries() logic is especially untested.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-process-manager",
          "dimension": "quality",
          "slug": "no-tests-process-manager",
          "title": "process_manager.py has no tests",
          "description": "backend/app/services/process_manager.py handles process tracking and cancellation but has no test file covering register/unregister/cancel flows or the race condition noted above.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-rate-limit-service",
          "dimension": "quality",
          "slug": "no-tests-rate-limit-service",
          "title": "rate_limit_service.py has no unit tests",
          "description": "backend/app/services/rate_limit_service.py manages rate limit state but has no dedicated test file. Rate limit edge cases (boundary hits, reset timing) are untested.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-frontend-composables",
          "dimension": "quality",
          "slug": "no-tests-frontend-composables",
          "title": "Core frontend composables have zero test coverage",
          "description": "frontend/src/composables/useConversation.ts, useAiChat.ts, useTeamCanvas.ts, and useOrgCanvas.ts have no test files. These contain complex logic (SSE handling, topology detection) that would benefit from unit tests.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-execution-service-unit-tests",
          "dimension": "quality",
          "slug": "missing-execution-service-unit-tests",
          "title": "Critical execution paths in execution_service.py lack unit tests",
          "description": "backend/app/services/execution_service.py: GitHub cloning failures, prompt template placeholder resolution, and stream handling edge cases (timeout, partial reads) are not unit-tested — only covered by broader integration tests.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/types-ts-monolith",
          "dimension": "quality",
          "slug": "types-ts-monolith",
          "title": "types.ts has 1567 lines mixing 15+ entity domains",
          "description": "frontend/src/services/api/types.ts is 1567 lines with 50+ types for agents, conversations, teams, skills, hooks, etc. all in one file. Split into domain-scoped files (types/agent.ts, types/team.ts, etc.) for maintainability.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-db-migration-error-handling",
          "dimension": "quality",
          "slug": "missing-db-migration-error-handling",
          "title": "DB migration exceptions silently caught",
          "description": "backend/app/db/migrations.py lines 2625, 2636: Two bare except Exception catches during schema migration silently log errors and continue, potentially leaving the database in a partially-migrated state without aborting.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-pty-cliproxy",
          "dimension": "quality",
          "slug": "no-tests-pty-cliproxy",
          "title": "No test coverage for pty_service and cliproxy_manager",
          "description": "backend/app/services/pty_service.py and cliproxy_manager.py contain process lifecycle management logic with no dedicated tests. Process startup, health check, and cleanup failure paths are completely untested, making regressions in CLI execution invisible.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-workflow-validation-cycle",
          "dimension": "quality",
          "slug": "no-tests-workflow-validation-cycle",
          "title": "No tests for cycle detection in useWorkflowValidation",
          "description": "frontend/src/composables/useWorkflowValidation.ts implements DFS-based cycle detection and port type compatibility matching. Neither algorithm has test coverage. Incorrect cycle detection could silently allow invalid workflow graphs that hang on execution.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-tests-composable-error-paths",
          "dimension": "quality",
          "slug": "no-tests-composable-error-paths",
          "title": "Composable error paths have no test coverage",
          "description": "frontend/src/composables/useAiChat.ts, useConversation.ts, and useProjectSession.ts have minimal tests that only cover happy paths. SSE reconnection, malformed event handling, session creation failure, and stream error events are all untested despite being critical user-facing failure modes.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/any-props-canvas-components",
          "dimension": "quality",
          "slug": "any-props-canvas-components",
          "title": "Untyped any[] props in canvas components",
          "description": "frontend/src/components/canvas/TeamCanvas.vue, OrgCanvas.vue, CanvasSidebar.vue, AgentDetailPanel.vue, and ProjectTeamCanvas.vue all declare props as `members: any[]`, `availableAgents: any[]`, `availableSuperAgents: any[]`. This disables type checking for the entire member/agent rendering pipeline.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/any-types-monitoring-charts",
          "dimension": "quality",
          "slug": "any-types-monitoring-charts",
          "title": "Untyped any[] in monitoring chart data structures",
          "description": "frontend/src/components/monitoring/CombinedUsageChart.vue, TokenUsageChart.vue, RotationTimelineChart.vue, and RemainingTimeChart.vue all use `const datasets: any[]` or `Record<number, any[]>` for chart data. Chart.js has full TypeScript types available that would catch data shape mismatches at compile time.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/broad-except-routes",
          "dimension": "quality",
          "slug": "broad-except-routes",
          "title": "Broad `except Exception` in route handlers without specific types",
          "description": "backend/app/routes/plugin_exports.py has 8+ instances of bare `except Exception as e:`. backend/app/__init__.py lines 150-236 uses multiple broad `except Exception` blocks in app initialization. Specific exceptions (sqlite3.Error, ValueError, KeyError) should be caught individually to avoid masking unexpected errors.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/router-guards-swallow-errors",
          "dimension": "quality",
          "slug": "router-guards-swallow-errors",
          "title": "Router guards indistinguishably swallow all errors",
          "description": "frontend/src/router/guards.ts lines 24-58: All 12 entity validators wrap API calls in try/catch returning false on any error. A 404 (entity doesn't exist) is treated the same as a network timeout or 500, leading to confusing redirects instead of proper error pages.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/composable-silent-catch-blocks",
          "dimension": "quality",
          "slug": "composable-silent-catch-blocks",
          "title": "15+ empty catch blocks in composables",
          "description": "frontend/src/composables/useProjectSession.ts lines 55, 71, 96 and throughout: over 15 catch (e) {} blocks with no logging or user feedback. Silent failures make client-side debugging very difficult.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-audit-log-service",
          "dimension": "quality",
          "slug": "missing-tests-audit-log-service",
          "title": "New audit_log_service has no tests",
          "description": "backend/app/services/audit_log_service.py: Recently added service with no test file verifying JSON format, field redaction, or integration with the logging pipeline. Any regression would go undetected.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-db-migrations",
          "dimension": "quality",
          "slug": "missing-tests-db-migrations",
          "title": "No automated migration correctness tests",
          "description": "backend/app/db/migrations.py: No tests verify that migrations run cleanly, produce the expected schema, or that rollback strategy works. A regression in migration logic could corrupt production data.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/missing-tests-frontend-api-client",
          "dimension": "quality",
          "slug": "missing-tests-frontend-api-client",
          "title": "API client retry/error logic untested",
          "description": "frontend/src/services/api/client.ts: The sophisticated retry logic (exponential backoff, jitter, 429 handling, SSE backpressure) has no unit tests. Coverage gaps in the network layer mean regressions will only be caught in production.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/template-placeholder-validation",
          "dimension": "quality",
          "slug": "template-placeholder-validation",
          "title": "Unknown prompt template placeholders silently pass",
          "description": "backend/app/services/execution_service.py lines 625-645: Warns about unknown placeholders but continues executing. A malformed template with bad placeholders produces a prompt with literal {placeholder} text instead of failing fast with a clear error.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/sse-events-not-validated",
          "dimension": "quality",
          "slug": "sse-events-not-validated",
          "title": "SSE event JSON not schema-validated before processing",
          "description": "frontend/src/composables/useConversation.ts around line 40: SSE stream parser processes server-sent JSON events without validating they match expected schema. Invalid events are silently skipped, hiding bugs in the event serialization layer.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "quality/no-pagination-on-list-endpoints",
          "dimension": "quality",
          "slug": "no-pagination-on-list-endpoints",
          "title": "List endpoints return unbounded results",
          "description": "backend/app/routes/: Endpoints like list_agents, list_bots, list_teams return all results without pagination. Organizations with hundreds of entities will experience degraded performance and large memory spikes.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 8.036585365853659,
      "effort": "large",
      "status": "pending"
    }
  ],
  "completed_groups": [
    {
      "id": "improve-features/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "improve-features",
      "title": "Miscellaneous (improve-features)",
      "items": [
        {
          "id": "improve-features/audit-log-ui-missing",
          "dimension": "improve-features",
          "slug": "audit-log-ui-missing",
          "title": "Audit log service exists but has no UI",
          "description": "backend/app/services/audit_log_service.py: Comprehensive audit logging is implemented, but many routes/services don't call it, and there's no frontend view to browse audit log entries. The feature is invisible to end users.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/no-retry-ui-for-failed-operations",
          "dimension": "improve-features",
          "slug": "no-retry-ui-for-failed-operations",
          "title": "No retry UI for failed executions or operations",
          "description": "frontend/src/views/WorkflowsPage.vue and execution views: When an execution fails, users must manually navigate back, reconfigure, and re-trigger. Add a 'Retry' button that replays the same parameters.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/rate-limit-approach-warning",
          "dimension": "improve-features",
          "slug": "rate-limit-approach-warning",
          "title": "No proactive warnings when approaching rate limits",
          "description": "backend/app/services/monitoring_service.py tracks rate limit usage, but the frontend has no indicator showing proximity to rate limits. Users discover limits only when executions start failing.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/sse-queue-drop-silent",
          "dimension": "improve-features",
          "slug": "sse-queue-drop-silent",
          "title": "SSE event drops are silent when queue is full",
          "description": "frontend/src/services/api/client.ts line 272: When SSE_MAX_QUEUE_SIZE (500) is exceeded, oldest events are dropped silently. This causes missed log lines in the execution view with no indication to the user that output was truncated.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "improve-features/config-no-schema-validation",
          "dimension": "improve-features",
          "slug": "config-no-schema-validation",
          "title": "YAML/JSON configs loaded without schema validation",
          "description": "Multiple backend services load YAML/JSON configuration files without schema validation. Invalid config keys or wrong types silently use defaults or fail at runtime deep in execution. Add JSON Schema or Pydantic validation at load time.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 14.6,
      "effort": "medium",
      "status": "completed"
    },
    {
      "id": "stability/miscellaneous",
      "theme": "miscellaneous",
      "dimension": "stability",
      "title": "Miscellaneous (stability)",
      "items": [
        {
          "id": "stability/swallowed-errors-execution-service",
          "dimension": "stability",
          "slug": "swallowed-errors-execution-service",
          "title": "Silent failure on repo clone error",
          "description": "backend/app/services/execution_service.py around line 598: GitHubService.clone_repo() is called without try/except. If clone fails, cloned_dirs cleanup may not execute, leaving temp dirs on disk and returning a misleading error to the caller.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/swallowed-errors-provider-usage-client",
          "dimension": "stability",
          "slug": "swallowed-errors-provider-usage-client",
          "title": "Bare except swallows credential resolution errors",
          "description": "backend/app/services/provider_usage_client.py around line 471: except (ValueError, TypeError) block swallows errors without logging. Silent failures hide misconfigurations, making it impossible to debug why token resolution failed.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/swallowed-errors-backend-detection",
          "dimension": "stability",
          "slug": "swallowed-errors-backend-detection",
          "title": "Generic except swallows subprocess errors in backend detection",
          "description": "backend/app/services/backend_detection_service.py line 81: bare except Exception catches all subprocess invocation errors without logging. Users cannot distinguish between missing binary, permission denied, or timeout.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/swallowed-errors-message-bus",
          "dimension": "stability",
          "slug": "swallowed-errors-message-bus",
          "title": "Silent failure drops messages in agent message bus",
          "description": "backend/app/services/agent_message_bus_service.py line 236: except Exception with no logging. Silent failure in message bus can silently drop messages without any trace in logs.",
          "effort": "small",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/in-memory-execution-state-lost-on-restart",
          "dimension": "stability",
          "slug": "in-memory-execution-state-lost-on-restart",
          "title": "In-memory execution state lost on server restart",
          "description": "ExecutionService, WorkflowExecutionService, and TeamExecutionService each maintain independent in-memory execution state dicts protected by locks. A server restart or crash silently loses all in-progress execution state. Persist active execution records to the database.",
          "effort": "large",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/no-api-rate-limiting",
          "dimension": "stability",
          "slug": "no-api-rate-limiting",
          "title": "No rate limiting on API endpoints",
          "description": "backend/app/routes/: None of the ~40 route handlers apply rate limiting. Any client can hammer endpoints without throttling. Add Flask-Limiter or similar middleware, especially on execution dispatch and webhook ingestion routes.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/blocking-git-clone-in-execution-thread",
          "dimension": "stability",
          "slug": "blocking-git-clone-in-execution-thread",
          "title": "Blocking git clone on execution thread",
          "description": "backend/app/services/execution_service.py around line 598: Large repository clones block the execution thread synchronously. A slow or large repo clone stalls the entire trigger execution pipeline. Offload to a thread pool or async queue.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        },
        {
          "id": "stability/no-api-versioning",
          "dimension": "stability",
          "slug": "no-api-versioning",
          "title": "No API versioning strategy",
          "description": "frontend/src/services/api/client.ts and backend/app/routes/: No versioning on API routes (no /v1/ prefix or Accept-Version header). Breaking backend changes silently break already-deployed frontends with no migration path.",
          "effort": "medium",
          "source": "discovery",
          "status": "pending",
          "iteration_added": 1
        }
      ],
      "priority": 13.375,
      "effort": "medium",
      "status": "completed"
    }
  ],
  "failed_groups": [],
  "all_items_count": 39,
  "groups_count": 8,
  "history": [
    {
      "iteration": 1,
      "timestamp": "2026-02-24T15:19:14.147Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 2,
      "timestamp": "2026-02-24T15:50:52.883Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 3,
      "timestamp": "2026-02-24T16:11:28.004Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 4,
      "timestamp": "2026-02-24T16:54:11.804Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 5,
      "timestamp": "2026-02-24T17:27:46.364Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 6,
      "timestamp": "2026-02-24T17:57:10.017Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 7,
      "timestamp": "2026-02-24T18:29:32.592Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 8,
      "timestamp": "2026-02-24T19:11:28.592Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 9,
      "timestamp": "2026-02-24T19:45:24.461Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 10,
      "timestamp": "2026-02-24T20:04:18.669Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 11,
      "timestamp": "2026-02-24T20:43:07.272Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 12,
      "timestamp": "2026-02-24T21:14:56.722Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 13,
      "timestamp": "2026-02-24T21:38:53.973Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    },
    {
      "iteration": 14,
      "timestamp": "2026-02-24T22:12:11.331Z",
      "selected_count": 2,
      "completed_count": 2,
      "failed_count": 0
    }
  ]
}
